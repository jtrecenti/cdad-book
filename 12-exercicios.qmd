---
title: Exerc√≠cios
format: live-html
---

```{pyodide}
#| setup: true
# SETUP GLOBAL ‚Äî carrega e normaliza a base `camaras` para todos os exerc√≠cios
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"

try:
    camaras_raw = pd.read_csv(url, dtype=str)
except Exception:
    camaras_raw = pd.DataFrame()

# Normalizar nomes de colunas
camaras_raw.columns = [str(c).strip() for c in camaras_raw.columns]
camaras = camaras_raw.copy()
camaras.columns = [c.lower().replace(" ", "_") for c in camaras.columns]

# Garantir colunas usadas nos exerc√≠cios (cria se n√£o existir)
expected_cols = (
    "decisao", "camara", "relator", "rel_idade", 
    "rel_tempo_magistratura", "partido", "votos_sim", 
    "dt_publicacao", "processo", "assunto", "ementa", "ano"
)
for col in expected_cols:
    if col not in camaras.columns:
        camaras[col] = pd.NA

# Tentar criar coluna 'ano' a partir de 'dt_publicacao' se existir
if "ano" not in camaras.columns and "dt_publicacao" in camaras.columns:
    try:
        camaras["ano"] = pd.to_datetime(camaras["dt_publicacao"], errors="coerce").dt.year
    except Exception:
        camaras["ano"] = pd.NA

print("‚úÖ SETUP GLOBAL OK ‚Äî linhas:", len(camaras), "colunas:", list(camaras.columns)[:15])
```


## Exerc√≠cio 1 ‚Äî **Panorama de Decis√µes**
 
Uma autoridade do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)** solicitou um relat√≥rio preliminar que apresente um panorama geral das decis√µes proferidas nas **C√¢maras Criminais**.  

O objetivo √© compreender a **distribui√ß√£o das decis√µes** conforme o tipo de provimento concedido ‚Äî se os recursos foram **negados**, **providos**, **parcialmente providos** ou se houve **extin√ß√£o da punibilidade**.  

Esse levantamento servir√° como base para um **estudo comparativo futuro** entre o TJSP e outros tribunais estaduais, buscando identificar poss√≠veis **padr√µes de julgamento** e **varia√ß√µes na aplica√ß√£o de precedentes**.  

***

Utilizando a base de dados `camaras`, elabore um **resumo quantitativo das decis√µes**, agrupando-as por **tipo de decis√£o**.  

```{pyodide}
#| setup: true
#| exercise: ex_1
import pandas as pd
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
print("SETUP ok ‚Äî colunas:", list(camaras.columns)[:10])
```

```{pyodide}
#| exercise: ex_1
# Escreva sua solu√ß√£o aqui:
# Agrupe as decis√µes usando value_counts() e renomeie a coluna de contagem.
```

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 1
Use `camaras["decisao"].value_counts()` para contar quantas vezes cada tipo de decis√£o aparece.
:::
:::

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 2
 Depois, transforme o resultado em DataFrame com `.reset_index(name="qtd_decisoes")`.
:::
:::

::: { .solution exercise="ex_1" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
total_decisoes = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes")
total_decisoes.head()
```
:::
:::

```{pyodide}
#| exercise: ex_1
#| check: true
# Checador autom√°tico ‚Äî compara o resultado do aluno com o DataFrame esperado.

import pandas as pd
feedback = None
try:
    expected = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes").reset_index(drop=True)
    if isinstance(result, pd.DataFrame):
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        # tenta identificar colunas
        if "decisao" in res.columns or "index" in res.columns:
            ok_cols = any("qtd" in c for c in res.columns)
            if ok_cols and len(res) == len(expected):
                feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî seu resumo de decis√µes est√° correto!"}
            else:
                feedback = {"correct": False, "message": "As colunas ou contagens n√£o correspondem. Verifique o uso de value_counts() e reset_index()."}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter a coluna 'decisao' e a contagem ('qtd_decisoes')."}
    else:
        feedback = {"correct": False, "message": "Retorne um DataFrame (total_decisoes) para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}

feedback
```

### Exerc√≠cio 1.1 ‚Äî **Visualiza√ß√£o do Panorama de Decis√µes**

 

A autoridade respons√°vel avaliou o relat√≥rio preliminar e solicitou que os resultados fossem apresentados de forma **mais visual**, para facilitar a compreens√£o em reuni√µes e apresenta√ß√µes p√∫blicas.  

Ela pediu que voc√™ **represente graficamente** a quantidade de decis√µes por tipo de provimento, a fim de destacar de maneira intuitiva **quais tipos de decis√£o s√£o mais comuns**.  

---

 
Com base no DataFrame `total_decisoes`, elabore um **gr√°fico de barras horizontais** que mostre a quantidade de decis√µes em cada categoria.  


---

```{pyodide}
#| setup: true
#| exercise: ex_1_1
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
total_decisoes = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes")
total_decisoes.rename(columns={"index": "decisao"}, inplace=True)
```

```{pyodide}
#| exercise: ex_1_1
# --- Escreva sua solu√ß√£o aqui ---


```

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 1  
O DataFrame `total_decisoes` j√° cont√©m as colunas `decisao` e `qtd_decisoes`.  
Use `sns.barplot()` para representar visualmente os valores.
:::
:::

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 2
Defina `y="decisao"` e `x="qtd_decisoes"` para gerar um gr√°fico de barras horizontais.  
A cor pode ser escolhida com `color="royalblue"`.
:::
:::

::: { .solution exercise="ex_1_1" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
sns.barplot(
    data=total_decisoes,
    y="decisao",
    x="qtd_decisoes",
    color="royalblue"
)
plt.title("Distribui√ß√£o das Decis√µes por Tipo de Provimento", fontsize=12)
plt.xlabel("Quantidade de Decis√µes")
plt.ylabel("Tipo de Decis√£o")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_1_1
#| check: true
# Checador autom√°tico ‚Äî verifica se o gr√°fico foi gerado a partir do DataFrame correto.
import pandas as pd
feedback = None
try:
    if "total_decisoes" in locals():
        ok_cols = {"decisao","qtd_decisoes"}.issubset(set(total_decisoes.columns))
        if ok_cols:
            feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî gr√°fico criado com base em total_decisoes!"}
        else:
            feedback = {"correct": False, "message": "O DataFrame total_decisoes deve conter as colunas 'decisao' e 'qtd_decisoes'."}
    else:
        feedback = {"correct": False, "message": "Certifique-se de usar o DataFrame total_decisoes gerado no exerc√≠cio anterior."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A **visualiza√ß√£o de dados** √© uma ferramenta poderosa para a **gest√£o judici√°ria** e para a **pesquisa emp√≠rica do Direito**. Gr√°ficos simples podem revelar padr√µes que passam despercebidos em planilhas ‚Äî como a **frequ√™ncia de negativas de provimento** ou a **raridade de determinadas decis√µes**.
:::


## Exerc√≠cio 2 ‚Äî **Distribui√ß√£o de Decis√µes por C√¢mara**



Em seguida, vamos supor que a mesma autoridade tenha solicitado uma **an√°lise complementar** com o objetivo de verificar a **quantidade de decis√µes proferidas por cada C√¢mara** do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)**.  

Como essa apresenta√ß√£o ser√° encaminhada para um **congresso dedicado ao estudo da distribui√ß√£o de decis√µes entre as C√¢maras**, optou-se por representar os resultados em **formato gr√°fico**, de modo a proporcionar uma visualiza√ß√£o mais clara, comparativa e intuitiva do volume de decis√µes analisadas.  

---

Utilizando a base `camaras`, elabore um **gr√°fico de barras** que mostre a quantidade total de decis√µes por **C√¢mara** (`camara`).  


---

```{pyodide}
#| setup: true
#| exercise: ex_2
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
```

```{pyodide}
#| exercise: ex_2
# Escreva sua solu√ß√£o aqui:
# Agrupe por 'camara' e conte as decis√µes.
# Gere um gr√°fico de barras (horizontal) com seaborn.


```

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 1
Use `value_counts()` para contar quantas decis√µes h√° em cada C√¢mara.
:::
:::

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 2 
Para visualizar, use `sns.barplot()` com `x='qtd_decisoes'`, `y='camara'` e uma cor (`color='royalblue'`).
:::
:::

::: { .solution exercise="ex_2" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
total_decisoes_por_camara = camaras["camara"].value_counts().reset_index(name="qtd_decisoes")

sns.barplot(
    data=total_decisoes_por_camara,
    y="camara",
    x="qtd_decisoes",
    color="royalblue"
)
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_2
#| check: true
import pandas as pd
feedback = None
try:
    expected = camaras["camara"].value_counts().reset_index(name="qtd_decisoes").reset_index(drop=True)
    if isinstance(result, pd.DataFrame):
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        if "camara" in res.columns and any("qtd" in c for c in res.columns):
            if len(res) == len(expected):
                feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî gr√°fico e tabela de decis√µes por C√¢mara est√£o corretos!"}
            else:
                feedback = {"correct": False, "message": "A contagem n√£o bate com o esperado. Verifique se usou value_counts()."}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter colunas 'camara' e 'qtd_decisoes'."}
    else:
        feedback = {"correct": False, "message": "Retorne o DataFrame total_decisoes_por_camara antes do gr√°fico para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A realiza√ß√£o desse tipo de **an√°lise √© especialmente relevante para o profissional do Direito**, porque promove uma **compreens√£o emp√≠rica e quantitativa da atua√ß√£o jurisdicional**.  

Ao examinar a **distribui√ß√£o de decis√µes entre as C√¢maras**, o operador do Direito pode identificar **padr√µes de produtividade, especializa√ß√£o e volume de demandas** ‚Äî elementos essenciais para a **gest√£o judici√°ria eficiente** e para o **aperfei√ßoamento das pol√≠ticas p√∫blicas de justi√ßa**.
:::



## Exerc√≠cio 3 ‚Äî **Padr√£o Decis√≥rio Comparado**

  

Uma equipe de pesquisa da **Escola da Magistratura** est√° conduzindo um estudo sobre **padr√µes de decis√£o entre diferentes relatores** das **C√¢maras Criminais do TJSP**.  

O objetivo √© verificar se existem **diferen√ßas percept√≠veis no comportamento decis√≥rio** de magistrados ‚Äî por exemplo, se um relator tende a negar mais recursos do que outro, ou se h√° maior propens√£o a decis√µes **parcialmente providas**.  

Para iniciar o estudo, a equipe selecionou dois relatores com grande volume de decis√µes no acervo:  

- **M√°rio Devienne Ferraz**  
- **Alberto Anderson Filho**

O foco √© **comparar o perfil decis√≥rio** desses dois magistrados quanto √† vari√°vel **‚Äúdecis√£o‚Äù**, que representa o resultado do julgamento do recurso.  

---


Filtre a base `camaras` para manter **somente as decis√µes** proferidas pelos relatores acima e salvar o resultado em `rel_comparacao`e utilize o Seaborn para **criar um gr√°fico de barras horizontais** que compare a quantidade de decis√µes de cada tipo (`DECISAO`) entre os dois relatores.  
A ideia √© gerar barras agrupadas por `DECISAO` com `hue` indicando o `RELATOR`.


---

```{pyodide}
#| setup: true
#| exercise: ex_3
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().upper().replace(" ", "_") for c in camaras.columns]
print("SETUP OK ‚Äî colunas:", list(camaras.columns)[:10])
```

```{pyodide}
#| exercise: ex_3
# --- Escreva sua solu√ß√£o aqui ---

rel_comparacao = _________________




sns._______________

```

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 1 
Crie uma lista com os dois nomes de relatores e use `query('RELATOR == @rel_comparacao')` para filtrar a base.
:::
:::

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 2
Para o gr√°fico, use `sns.countplot()` e mapeie `y='RELATOR'`, `hue='DECISAO'` e `palette='flare'`.
:::
:::

::: { .solution exercise="ex_3" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
rel_comparacao = ['M√ÅRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO']
rel_comparacao = camaras.query('RELATOR == @rel_comparacao')

sns.countplot(
    data=rel_comparacao,
    y='RELATOR',
    hue='DECISAO',
    palette='flare'
)
plt.title("Padr√£o Decis√≥rio Comparado ‚Äî TJSP", fontsize=12)
plt.xlabel("Quantidade de Decis√µes")
plt.ylabel("Relator")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_3
#| check: true
# Checador simples ‚Äî verifica se o DataFrame 'rel_comparacao' foi criado corretamente.
import pandas as pd
feedback = None
try:
    expected = ['M√ÅRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO']
    if isinstance(result, pd.DataFrame):
        if 'RELATOR' in result.columns:
            relatores_encontrados = sorted(result['RELATOR'].unique().tolist())
            relatores_esperados = sorted(expected)
            if relatores_encontrados == relatores_esperados:
                feedback = {"correct": True, "message": "Excelente üéâ ‚Äî filtrou corretamente os dois relatores!"}
            else:
                feedback = {"correct": False, "message": f"Os relatores filtrados n√£o correspondem. Esperado: {relatores_esperados}"}
        else:
            feedback = {"correct": False, "message": "Seu DataFrame precisa conter a coluna 'RELATOR'."}
    else:
        feedback = {"correct": False, "message": "Retorne o DataFrame rel_comparacao antes do gr√°fico para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

**Comparar padr√µes decis√≥rios entre relatores** √© uma t√©cnica frequentemente utilizada em estudos de **Direito e Tecnologia**.  
Essa abordagem permite investigar a **consist√™ncia e previsibilidade das decis√µes judiciais**, bem como discutir o papel da **subjetividade judicial** no contexto dos tribunais.
:::



## Exerc√≠cio 4 ‚Äî **Idade x Padr√£o Decis√≥rio**

 

Dando sequ√™ncia ao estudo desenvolvido pela **equipe de pesquisa em Direito e Ci√™ncia de Dados**, que vem atendendo √†s solicita√ß√µes de uma autoridade do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)**, surge uma nova quest√£o de interesse.  

Ap√≥s observar **diferen√ßas de comportamento entre relatores** nas an√°lises anteriores, a equipe foi instigada a investigar se a **idade dos magistrados pode estar relacionada ao tipo de decis√£o proferida**.  

A hip√≥tese √© de que **relatores mais experientes** ‚Äî e, portanto, com **maior idade** ‚Äî possam apresentar **tend√™ncias distintas** em rela√ß√£o √† concess√£o ou nega√ß√£o de recursos.  

O objetivo deste exerc√≠cio √© verificar se h√° alguma **correla√ß√£o entre a idade dos relatores e o padr√£o de decis√µes proferidas**.  

Crie tabelas que permitam comparar a idade dos relatores com a **quantidade de decis√µes de cada tipo**.  
A autoridade do TJSP solicitou que a equipe apresentasse uma **visualiza√ß√£o gr√°fica** que pudesse indicar se existe **rela√ß√£o entre a idade dos relatores e o n√∫mero de decis√µes negativas (‚ÄúNegaram‚Äù)**.  

O objetivo √© observar poss√≠veis **tend√™ncias et√°rias no comportamento decis√≥rio** das C√¢maras Criminais.  

---

 
Crie uma tabela com o n√∫mero de decis√µes de cada tipo por relator.  
Crie outra tabela com a idade de cada relator (`rel_idade`).  
Fa√ßa um **merge** das duas tabelas, resultando em `decisoes_idade`.  
Elabore um **gr√°fico de dispers√£o (`sns.scatterplot`)** mostrando `rel_idade` (x) versus o n√∫mero de decis√µes ‚ÄúNegaram‚Äù (y).

---

```{pyodide}
#| setup: true
#| exercise: ex_4
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().replace(" ", "_") for c in camaras.columns]
print("SETUP ok ‚Äî colunas:", list(camaras.columns)[:10])
```

```{pyodide}
#| exercise: ex_4
# --- Escreva sua solu√ß√£o aqui ---


```

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 1  
Use `groupby(['relator','decisao']).size().unstack(fill_value=0)` para montar a tabela de decis√µes por relator.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 2 
Para associar a idade de cada relator, remova duplicatas (`drop_duplicates('relator')`) e selecione `['relator','rel_idade']`.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 3
Depois, use `pd.merge()` para juntar as duas tabelas e gere o gr√°fico de dispers√£o (`sns.scatterplot`).
:::
:::

::: { .solution exercise="ex_4" }
::: { .callout-tip collapse="false" }
##  Solu√ß√£o
```python
# TABELA DE TIPO DE DECIS√ïES POR RELATOR 
decisoes_relator = camaras.groupby(['relator', 'decisao']).size().unstack(fill_value=0)

# TABELA DE IDADES POR RELATOR 
camaras_semduplicatas = camaras.drop_duplicates('relator')
idade_relator = camaras_semduplicatas[['relator', 'rel_idade']]

# JUN√á√ÉO DA IDADE COM AS DECIS√ïES
decisoes_relator = decisoes_relator.reset_index()
decisoes_idade = pd.merge(decisoes_relator, idade_relator, on='relator').reset_index()

# GR√ÅFICO DE DISPERS√ÉO
sns.scatterplot(data=decisoes_idade, x='rel_idade', y='Negaram')
plt.title("Rela√ß√£o entre Idade e Decis√µes Negativas (TJSP)")
plt.xlabel("Idade do Relator")
plt.ylabel("N√∫mero de Decis√µes 'Negaram'")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_4
#| check: true
# Checador autom√°tico ‚Äî verifica se 'decisoes_idade' cont√©m colunas esperadas e merge correto.
import pandas as pd
feedback = None
try:
    # monta vers√£o esperada m√≠nima
    decisoes_relator = camaras.groupby(['relator','decisao']).size().unstack(fill_value=0).reset_index()
    camaras_semduplicatas = camaras.drop_duplicates('relator')
    idade_relator = camaras_semduplicatas[['relator','rel_idade']]
    esperado = pd.merge(decisoes_relator, idade_relator, on='relator').reset_index(drop=True)

    if isinstance(result, pd.DataFrame):
        cols_necessarias = {'relator','rel_idade','Negaram'}
        if cols_necessarias.issubset(set(result.columns)):
            feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî voc√™ combinou corretamente as tabelas e gerou a base para o gr√°fico!"}
        else:
            faltando = cols_necessarias - set(result.columns)
            feedback = {"correct": False, "message": f"Faltam colunas esperadas: {faltando}. Verifique a jun√ß√£o e nomes das colunas."}
    else:
        feedback = {"correct": False, "message": "Retorne o DataFrame (decisoes_idade) antes do gr√°fico para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A **an√°lise emp√≠rica da atua√ß√£o judicial** permite discutir at√© que ponto **fatores pessoais**, como **idade** e **tempo de carreira**, influenciam os resultados das decis√µes.  

Embora **correla√ß√£o n√£o implique causalidade**, tais estudos s√£o fundamentais para compreender a **diversidade de perfis decis√≥rios** e para fomentar **pol√≠ticas de uniformiza√ß√£o jurisprudencial** e **gest√£o da magistratura**.
:::


##  Exerc√≠cio 5 ‚Äî **Idade x Tempo de Magistratura**

 

Dando prosseguimento ao estudo conduzido pela **equipe de pesquisa em Direito e Ci√™ncia de Dados**, que tem elaborado relat√≥rios anal√≠ticos para uma autoridade do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)**, o grupo decidiu agora examinar a **rela√ß√£o entre a idade dos relatores e o tempo de magistratura**.  

A inten√ß√£o √© compreender se existe **correla√ß√£o entre essas duas vari√°veis** ‚Äî o que pode ajudar a **validar os dados coletados** e oferecer um retrato mais preciso do **perfil dos julgadores** que atuam nas **C√¢maras Criminais**.  

---  

 **Selecione apenas uma linha por relator**, contendo suas informa√ß√µes de idade (`rel_idade`) e tempo de magistratura (`rel_tempo_magistratura`).  
 Crie um **gr√°fico de dispers√£o (`sns.scatterplot`)**, em que:  
   - o eixo **x** representa a idade (`rel_idade`);  
   - o eixo **y** representa o tempo de magistratura (`rel_tempo_magistratura`).  

O objetivo √© verificar visualmente se existe **correla√ß√£o positiva entre idade e tempo de magistratura** ‚Äî hip√≥tese que validaria a consist√™ncia dos dados.

---

```{pyodide}
#| setup: true
#| exercise: ex_5
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().replace(" ", "_") for c in camaras.columns]
print("SETUP ok ‚Äî colunas:", list(camaras.columns)[:10])
```

```{pyodide}
#| exercise: ex_5
# --- Escreva sua solu√ß√£o aqui ---

```

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 1
Use `drop_duplicates('relator')` para garantir **apenas uma linha por relator** no DataFrame.
:::
:::

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 2 
Monte o gr√°fico com `sns.scatterplot()`, definindo `x='rel_idade'` e `y='rel_tempo_magistratura'`.  
Isso criar√° um **gr√°fico de dispers√£o** que permite observar a correla√ß√£o entre idade e tempo de carreira.
:::
:::

::: { .solution exercise="ex_5" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
relatores = camaras.drop_duplicates('relator')  # Uma linha por relator
sns.scatterplot(
    data=relatores,
    x='rel_idade',
    y='rel_tempo_magistratura'
)
plt.title("Correla√ß√£o entre Idade e Tempo de Magistratura (TJSP)", fontsize=12)
plt.xlabel("Idade do Relator")
plt.ylabel("Tempo de Magistratura (anos)")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_5
#| check: true
# Checador autom√°tico ‚Äî valida se o DataFrame 'relatores' cont√©m as colunas esperadas.
import pandas as pd
feedback = None
try:
    relatores_esperado = camaras.drop_duplicates('relator')
    if isinstance(result, pd.DataFrame):
        if {'rel_idade','rel_tempo_magistratura'}.issubset(result.columns):
            feedback = {"correct": True, "message": "Excelente üéâ ‚Äî rela√ß√£o entre idade e tempo de magistratura identificada corretamente!"}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter as colunas 'rel_idade' e 'rel_tempo_magistratura'."}
    else:
        feedback = {"correct": False, "message": "Retorne o DataFrame (relatores) antes do gr√°fico para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

O **cruzamento entre idade e tempo de magistratura** √© √∫til n√£o apenas para a **valida√ß√£o dos dados**, mas tamb√©m para refletir sobre **trajet√≥rias profissionais** e a forma√ß√£o de **cultura institucional** dentro do **Poder Judici√°rio**.  

Ao compreender o **perfil de carreira dos relatores**, a equipe pode investigar com mais profundidade como a **experi√™ncia influencia padr√µes decis√≥rios** e a **estabilidade jurisprudencial**.
:::



