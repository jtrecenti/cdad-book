---
title: ExercÃ­cios
format: live-html
pyodide:
  packages:
    - pandas
    - matplotlib
    - seaborn
---

```{pyodide}
#| envir: myenv
# Bloco 1: APENAS IMPORTA AS BIBLIOTECAS
import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import warnings

warnings.simplefilter(action='ignore', category=FutureWarning)
print("Setup Global OK: Bibliotecas carregadas em 'myenv'.")
```

## ExercÃ­cio 1 â€” **Panorama de DecisÃµes**
 
Uma autoridade do **Tribunal de JustiÃ§a de SÃ£o Paulo (TJSP)** solicitou um relatÃ³rio preliminar que apresente um panorama geral das decisÃµes proferidas nas **CÃ¢maras Criminais**.  

O objetivo Ã© compreender a **distribuiÃ§Ã£o das decisÃµes** conforme o tipo de provimento concedido â€” se os recursos foram **negados**, **providos**, **parcialmente providos** ou se houve **extinÃ§Ã£o da punibilidade**.  

Esse levantamento servirÃ¡ como base para um **estudo comparativo futuro** entre o TJSP e outros tribunais estaduais, buscando identificar possÃ­veis **padrÃµes de julgamento** e **variaÃ§Ãµes na aplicaÃ§Ã£o de precedentes**.  

***

Utilizando a base de dados `camaras`, elabore um **resumo quantitativo das decisÃµes**, agrupando-as por **tipo de decisÃ£o**.  

```{pyodide}
#| exercise: ex_1
#| envir: myenv

# Prepara a base 'camaras' para este exercÃ­cio
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]

# Escreva sua soluÃ§Ã£o aqui:
# Agrupe as decisÃµes usando value_counts() e renomeie a coluna de contagem.
```

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 1
Use `camaras["decisao"].value_counts()` para contar quantas vezes cada tipo de decisÃ£o aparece na base.
:::
:::

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 2
 Depois de obter a contagem, transforme o resultado em um **DataFrame** usando  `.reset_index(name="qtd_decisoes")`  
e **renomeie a coluna** `"index"` para `"decisao"` com: `total_decisoes = total_decisoes.rename(columns={"index": "decisao"})`.  

Por fim, use `.reset_index(drop=True)` para garantir que os Ã­ndices fiquem limpos antes de retornar o DataFrame.
:::
:::

::: { .solution exercise="ex_1" }
::: { .callout-tip collapse="false" }
## SoluÃ§Ã£o
```python
total_decisoes = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes")
total_decisoes = total_decisoes.rename(columns={"index": "decisao"})
total_decisoes = total_decisoes.reset_index(drop=True)
total_decisoes
```
:::
:::

```{pyodide}
#| exercise: ex_1
#| check: true
#| envir: myenv
# Checador automÃ¡tico â€” compara o resultado do aluno com o DataFrame esperado.

import pandas as pd
feedback = None
result = None
try:
    # CORREÃ‡ÃƒO: Captura a variÃ¡vel de resposta do aluno
    result = total_decisoes 
    
    # Prepara a base 'camaras' (deve ser igual ao do aluno)
    url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
Â  Â  camaras = pd.read_csv(url, dtype=str)
Â  Â  camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
Â  Â  expected = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes").reset_index(drop=True)
    
    if isinstance(result, pd.DataFrame):
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        # tenta identificar colunas
        if "decisao" in res.columns or "index" in res.columns:
            ok_cols = any("qtd" in c for c in res.columns)
            if ok_cols and len(res) == len(expected):
                feedback = {"correct": True, "message": "Perfeito ğŸ‰ â€” seu resumo de decisÃµes estÃ¡ correto!"}
            else:
                feedback = {"correct": False, "message": "As colunas ou contagens nÃ£o correspondem. Verifique o uso de value_counts() e reset_index()."}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter a coluna 'decisao' e a contagem ('qtd_decisoes')."}
    else:
        feedback = {"correct": False, "message": "Retorne um DataFrame (total_decisoes) para validaÃ§Ã£o."}

except NameError:
    feedback = {"correct": False, "message": "A variÃ¡vel 'total_decisoes' nÃ£o foi encontrada. Verifique o nome da sua variÃ¡vel."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}

feedback
```

### ExercÃ­cio 1.1 â€” **VisualizaÃ§Ã£o do Panorama de DecisÃµes**

 

A autoridade responsÃ¡vel avaliou o relatÃ³rio preliminar e solicitou que os resultados fossem apresentados de forma **mais visual**, para facilitar a compreensÃ£o em reuniÃµes e apresentaÃ§Ãµes pÃºblicas.  

Ela pediu que vocÃª **represente graficamente** a quantidade de decisÃµes por tipo de provimento, a fim de destacar de maneira intuitiva **quais tipos de decisÃ£o sÃ£o mais comuns**.  

---

 
Com base no DataFrame `total_decisoes`, elabore um **grÃ¡fico de barras horizontais** que mostre a quantidade de decisÃµes em cada categoria.  


---


```{pyodide}
#| exercise: ex_1_1
#| envir: myenv
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
# --- Escreva sua soluÃ§Ã£o aqui ---


```

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 1  
O DataFrame `total_decisoes` jÃ¡ contÃ©m as colunas `decisao` e `qtd_decisoes`.  
Use `sns.barplot()` para representar visualmente os valores.
:::
:::

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 2
Defina `y="decisao"` e `x="qtd_decisoes"` para gerar um grÃ¡fico de barras horizontais.  
A cor pode ser escolhida com `color="royalblue"`.
:::
:::

::: { .solution exercise="ex_1_1" }
::: { .callout-tip collapse="false" }
## SoluÃ§Ã£o
```python
sns.barplot(
    data=total_decisoes,
    y="decisao",
    x="qtd_decisoes",
    color="royalblue"
)
plt.title("DistribuiÃ§Ã£o das DecisÃµes por Tipo de Provimento", fontsize=12)
plt.xlabel("Quantidade de DecisÃµes")
plt.ylabel("Tipo de DecisÃ£o")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_1_1
#| check: true
#| envir: myenv
# Checador automÃ¡tico â€” verifica se o grÃ¡fico foi gerado a partir do DataFrame correto.
import pandas as pd
feedback = None
try:
    # Como o 'envir' Ã© compartilhado, 'total_decisoes' do Ex 1 estÃ¡ acessÃ­vel.
    if "total_decisoes" in locals(): 
        ok_cols = {"decisao","qtd_decisoes"}.issubset(set(total_decisoes.columns))
        if ok_cols:
            feedback = {"correct": True, "message": "Perfeito ğŸ‰ â€” grÃ¡fico criado com base em total_decisoes!"}
        else:
            feedback = {"correct": False, "message": "O DataFrame total_decisoes deve conter as colunas 'decisao' e 'qtd_decisoes'."}
    else:
        feedback = {"correct": False, "message": "Certifique-se de usar o DataFrame total_decisoes gerado no exercÃ­cio anterior."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="âš–ï¸"}
### RelevÃ¢ncia jurÃ­dica  

A **visualizaÃ§Ã£o de dados** Ã© uma ferramenta poderosa para a **gestÃ£o judiciÃ¡ria** e para a **pesquisa empÃ­rica do Direito**. GrÃ¡ficos simples podem revelar padrÃµes que passam despercebidos em planilhas â€” como a **frequÃªncia de negativas de provimento** ou a **raridade de determinadas decisÃµes**.
:::


## ExercÃ­cio 2 â€” **DistribuiÃ§Ã£o de DecisÃµes por CÃ¢mara**



Em seguida, vamos supor que a mesma autoridade tenha solicitado uma **anÃ¡lise complementar** com o objetivo de verificar a **quantidade de decisÃµes proferidas por cada CÃ¢mara** do **Tribunal de JustiÃ§a de SÃ£o Paulo (TJSP)**.  

Como essa apresentaÃ§Ã£o serÃ¡ encaminhada para um **congresso dedicado ao estudo da distribuiÃ§Ã£o de decisÃµes entre as CÃ¢maras**, optou-se por representar os resultados em **formato grÃ¡fico**, de modo a proporcionar uma visualizaÃ§Ã£o mais clara, comparativa e intuitiva do volume de decisÃµes analisadas.  

---

Utilizando a base `camaras`, elabore um **grÃ¡fico de barras** que mostre a quantidade total de decisÃµes por **CÃ¢mara** (`camara`).  


---

```{pyodide}
#| exercise: ex_2
#| envir: myenv

# Prepara a base 'camaras' para este exercÃ­cio
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]

# Escreva sua soluÃ§Ã£o aqui:
# Agrupe por 'camara' e conte as decisÃµes.
# Gere um grÃ¡fico de barras (horizontal) com seaborn.
```

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 1
Use `value_counts()` para contar quantas decisÃµes hÃ¡ em cada CÃ¢mara.
:::
:::

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 2 
Para visualizar, use `sns.barplot()` com `x='qtd_decisoes'`, `y='camara'` e uma cor (`color='royalblue'`).
:::
:::

::: { .solution exercise="ex_2" }
::: { .callout-tip collapse="false" }
## SoluÃ§Ã£o
```python
total_decisoes_por_camara = camaras["camara"].value_counts().reset_index(name="qtd_decisoes")

sns.barplot(
    data=total_decisoes_por_camara,
    y="camara",
    x="qtd_decisoes",
    color="royalblue"
)
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_2
#| check: true
#| envir: myenv

feedback = None
result = None 
try:
Â  Â  # Captura a variÃ¡vel de resposta do aluno
Â  Â  result = total_decisoes_por_camara
Â  Â  
Â  Â  # RE-CARREGA OS DADOS PARA CRIAR A RESPOSTA ESPERADA
Â  Â  url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
Â  Â  camaras = pd.read_csv(url, dtype=str)
Â  Â  camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
Â  Â  expected = camaras["camara"].value_counts().reset_index(name="qtd_decisoes").reset_index(drop=True)
Â  Â  
Â  Â  if isinstance(result, pd.DataFrame):
Â  Â  Â  Â  res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
Â  Â  Â  Â  if "camara" in res.columns and any("qtd" in c for c in res.columns):
Â  Â  Â  Â  Â  Â  if len(res) == len(expected):
Â  Â  Â  Â  Â  Â  Â  Â  feedback = {"correct": True, "message": "Perfeito ğŸ‰ â€” grÃ¡fico e tabela de decisÃµes por CÃ¢mara estÃ£o corretos!"}
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  feedback = {"correct": False, "message": "A contagem nÃ£o bate com o esperado. Verifique se usou value_counts()."}
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  feedback = {"correct": False, "message": "O DataFrame deve conter colunas 'camara' e 'qtd_decisoes'."}
Â  Â  else:
Â  Â  Â  Â  feedback = {"correct": False, "message": "Retorne o DataFrame total_decisoes_por_camara antes do grÃ¡fico para validaÃ§Ã£o."}

except NameError:
Â  Â  feedback = {"correct": False, "message": "A variÃ¡vel 'total_decisoes_por_camara' nÃ£o foi encontrada."}
except Exception as e:
Â  Â  feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="âš–ï¸"}
### RelevÃ¢ncia jurÃ­dica  

A realizaÃ§Ã£o desse tipo de **anÃ¡lise Ã© especialmente relevante para o profissional do Direito**, porque promove uma **compreensÃ£o empÃ­rica e quantitativa da atuaÃ§Ã£o jurisdicional**.  

Ao examinar a **distribuiÃ§Ã£o de decisÃµes entre as CÃ¢maras**, o operador do Direito pode identificar **padrÃµes de produtividade, especializaÃ§Ã£o e volume de demandas** â€” elementos essenciais para a **gestÃ£o judiciÃ¡ria eficiente** e para o **aperfeiÃ§oamento das polÃ­ticas pÃºblicas de justiÃ§a**.
:::



## ExercÃ­cio 3 â€” **PadrÃ£o DecisÃ³rio Comparado**

  

Uma equipe de pesquisa da **Escola da Magistratura** estÃ¡ conduzindo um estudo sobre **padrÃµes de decisÃ£o entre diferentes relatores** das **CÃ¢maras Criminais do TJSP**.  

O objetivo Ã© verificar se existem **diferenÃ§as perceptÃ­veis no comportamento decisÃ³rio** de magistrados â€” por exemplo, se um relator tende a negar mais recursos do que outro, ou se hÃ¡ maior propensÃ£o a decisÃµes **parcialmente providas**.  

Para iniciar o estudo, a equipe selecionou dois relatores com grande volume de decisÃµes no acervo:  

- **MÃ¡rio Devienne Ferraz**  
- **Alberto Anderson Filho**

O foco Ã© **comparar o perfil decisÃ³rio** desses dois magistrados quanto Ã  variÃ¡vel **â€œdecisÃ£oâ€**, que representa o resultado do julgamento do recurso.  

---


Filtre a base `camaras` para manter **somente as decisÃµes** proferidas pelos relatores acima e salvar o resultado em `rel_comparacao`e utilize o Seaborn para **criar um grÃ¡fico de barras horizontais** que compare a quantidade de decisÃµes de cada tipo (`DECISAO`) entre os dois relatores.  
A ideia Ã© gerar barras agrupadas por `DECISAO` com `hue` indicando o `RELATOR`.


---

```{pyodide}
#| exercise: ex_3
#| envir: myenv

# CARREGA OS DADOS E FORMATA EM MAIÃšSCULO
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().upper().replace(" ", "_") for c in camaras.columns]

# --- Escreva sua soluÃ§Ã£o aqui ---

rel_comparacao = _________________

sns._______________
```

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 1 
Crie uma lista com os dois nomes de relatores e use `query('RELATOR == @rel_comparacao')` para filtrar a base.
:::
:::

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 2
Para o grÃ¡fico, use `sns.countplot()` e mapeie `y='RELATOR'`, `hue='DECISAO'` e `palette='flare'`.
:::
:::

::: { .solution exercise="ex_3" }
::: { .callout-tip collapse="false" }
## SoluÃ§Ã£o
```python
rel_comparacao = ['MÃRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO']
rel_comparacao = camaras.query('RELATOR == @rel_comparacao')

sns.countplot(
    data=rel_comparacao,
    y='RELATOR',
    hue='DECISAO',
    palette='flare'
)
plt.title("PadrÃ£o DecisÃ³rio Comparado â€” TJSP", fontsize=12)
plt.xlabel("Quantidade de DecisÃµes")
plt.ylabel("Relator")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_3
#| check: true
#| envir: myenv

feedback = None
result = None
try:
Â  Â  # Captura a variÃ¡vel de resposta do aluno
Â  Â  result = rel_comparacao
Â  Â  
Â  Â  # RE-CARREGA OS DADOS PARA CRIAR A RESPOSTA ESPERADA
Â  Â  url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
Â  Â  camaras = pd.read_csv(url, dtype=str)
Â  Â  camaras.columns = [c.strip().upper().replace(" ", "_") for c in camaras.columns]
Â  Â  expected_names = ['MÃRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO']
Â  Â  
Â  Â  if isinstance(result, pd.DataFrame):
Â  Â  Â  Â  if 'RELATOR' in result.columns:
Â  Â  Â  Â  Â  Â  relatores_encontrados = sorted(result['RELATOR'].unique().tolist())
Â  Â  Â  Â  Â  Â  relatores_esperados = sorted(expected_names)
Â  Â  Â  Â  Â  Â  if relatores_encontrados == relatores_esperados:
Â  Â  Â  Â  Â  Â  Â  Â  feedback = {"correct": True, "message": "Excelente ğŸ‰ â€” filtrou corretamente os dois relatores!"}
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  feedback = {"correct": False, "message": f"Os relatores filtrados nÃ£o correspondem. Esperado: {relatores_esperados}"}
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  feedback = {"correct": False, "message": "Seu DataFrame precisa conter a coluna 'RELATOR'."}
Â  Â  else:
Â  Â  Â  Â  feedback = {"correct": False, "message": "Retorne o DataFrame rel_comparacao antes do grÃ¡fico para validaÃ§Ã£o."}

except NameError:
Â  Â  feedback = {"correct": False, "message": "A variÃ¡vel 'rel_comparacao' nÃ£o foi encontrada."}
except Exception as e:
Â  Â  feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="âš–ï¸"}
### RelevÃ¢ncia jurÃ­dica  

**Comparar padrÃµes decisÃ³rios entre relatores** Ã© uma tÃ©cnica frequentemente utilizada em estudos de **Direito e Tecnologia**.  
Essa abordagem permite investigar a **consistÃªncia e previsibilidade das decisÃµes judiciais**, bem como discutir o papel da **subjetividade judicial** no contexto dos tribunais.
:::



## ExercÃ­cio 4 â€” **Idade x PadrÃ£o DecisÃ³rio**

 

Dando sequÃªncia ao estudo desenvolvido pela **equipe de pesquisa em Direito e CiÃªncia de Dados**, que vem atendendo Ã s solicitaÃ§Ãµes de uma autoridade do **Tribunal de JustiÃ§a de SÃ£o Paulo (TJSP)**, surge uma nova questÃ£o de interesse.  

ApÃ³s observar **diferenÃ§as de comportamento entre relatores** nas anÃ¡lises anteriores, a equipe foi instigada a investigar se a **idade dos magistrados pode estar relacionada ao tipo de decisÃ£o proferida**.  

A hipÃ³tese Ã© de que **relatores mais experientes** â€” e, portanto, com **maior idade** â€” possam apresentar **tendÃªncias distintas** em relaÃ§Ã£o Ã  concessÃ£o ou negaÃ§Ã£o de recursos.  

O objetivo deste exercÃ­cio Ã© verificar se hÃ¡ alguma **correlaÃ§Ã£o entre a idade dos relatores e o padrÃ£o de decisÃµes proferidas**.  

Crie tabelas que permitam comparar a idade dos relatores com a **quantidade de decisÃµes de cada tipo**.  
A autoridade do TJSP solicitou que a equipe apresentasse uma **visualizaÃ§Ã£o grÃ¡fica** que pudesse indicar se existe **relaÃ§Ã£o entre a idade dos relatores e o nÃºmero de decisÃµes negativas (â€œNegaramâ€)**.  

O objetivo Ã© observar possÃ­veis **tendÃªncias etÃ¡rias no comportamento decisÃ³rio** das CÃ¢maras Criminais.  

---

 
Crie uma tabela com o nÃºmero de decisÃµes de cada tipo por relator.  
Crie outra tabela com a idade de cada relator (`rel_idade`).  
FaÃ§a um **merge** das duas tabelas, resultando em `decisoes_idade`.  
Elabore um **grÃ¡fico de dispersÃ£o (`sns.scatterplot`)** mostrando `rel_idade` (x) versus o nÃºmero de decisÃµes â€œNegaramâ€ (y).

---

```{pyodide}
#| exercise: ex_4
#| envir: myenv

# CARREGA OS DADOS DENTRO DO BLOCO DO EXERCÃCIO
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().replace(" ", "_") for c in camaras.columns]

# --- Escreva sua solution aqui ---
```

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 1  
Use `groupby(['relator','decisao']).size().unstack(fill_value=0)` para montar a tabela de decisÃµes por relator.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 2 
Para associar a idade de cada relator, remova duplicatas (`drop_duplicates('relator')`) e selecione `['relator','rel_idade']`.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 3
Depois, use `pd.merge()` para juntar as duas tabelas e gere o grÃ¡fico de dispersÃ£o (`sns.scatterplot`).
:::
:::

::: { .solution exercise="ex_4" }
::: { .callout-tip collapse="false" }
##  SoluÃ§Ã£o
```python
# TABELA DE TIPO DE DECISÃ•ES POR RELATOR 
decisoes_relator = camaras.groupby(['relator', 'decisao']).size().unstack(fill_value=0)

# TABELA DE IDADES POR RELATOR 
camaras_semduplicatas = camaras.drop_duplicates('relator')
idade_relator = camaras_semduplicatas[['relator', 'rel_idade']]

# JUNÃ‡ÃƒO DA IDADE COM AS DECISÃ•ES
decisoes_relator = decisoes_relator.reset_index()
decisoes_idade = pd.merge(decisoes_relator, idade_relator, on='relator').reset_index()

# GRÃFICO DE DISPERSÃƒO
sns.scatterplot(data=decisoes_idade, x='rel_idade', y='Negaram')
plt.title("RelaÃ§Ã£o entre Idade e DecisÃµes Negativas (TJSP)")
plt.xlabel("Idade do Relator")
plt.ylabel("NÃºmero de DecisÃµes 'Negaram'")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_4
#| check: true
#| envir: myenv

feedback = None
result = None 
try:
Â  Â  # Captura a variÃ¡vel de resposta do aluno
Â  Â  result = decisoes_idade
Â  Â  
Â  Â  # RE-CARREGA OS DADOS PARA CRIAR A RESPOSTA ESPERADA
Â  Â  url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
Â  Â  camaras = pd.read_csv(url, dtype=str)
Â  Â  camaras.columns = [c.strip().replace(" ", "_") for c in camaras.columns]
Â  Â  
Â  Â  decisoes_relator = camaras.groupby(['relator','decisao']).size().unstack(fill_value=0).reset_index()
Â  Â  camaras_semduplicatas = camaras.drop_duplicates('relator')
Â  Â  idade_relator = camaras_semduplicatas[['relator','rel_idade']]
Â  Â  esperado = pd.merge(decisoes_relator, idade_relator, on='relator').reset_index(drop=True)

Â  Â  if isinstance(result, pd.DataFrame):
Â  Â  Â  Â  cols_necessarias = {'relator','rel_idade','Negaram'}
Â  Â  Â  Â  if cols_necessarias.issubset(set(result.columns)):
Â  Â  Â  Â  Â  Â  # Checagem simples (nÃ£o compara os valores, apenas se as colunas existem)
Â  Â  Â  Â  Â  Â  feedback = {"correct": True, "message": "Perfeito ğŸ‰ â€” vocÃª combinou corretamente as tabelas e gerou a base para o grÃ¡fico!"}
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  faltando = cols_necessarias - set(result.columns)
Â  Â  Â  Â  Â  Â  feedback = {"correct": False, "message": f"Faltam colunas esperadas: {faltando}. Verifique a junÃ§Ã£o e nomes das colunas."}
Â  Â  else:
Â  Â  Â  Â  feedback = {"correct": False, "message": "Retorne o DataFrame (decisoes_idade) antes do grÃ¡fico para validaÃ§Ã£o."}

except NameError:
Â  Â  feedback = {"correct": False, "message": "A variÃ¡vel 'decisoes_idade' nÃ£o foi encontrada."}
except Exception as e:
Â  Â  feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="âš–ï¸"}
### RelevÃ¢ncia jurÃ­dica  

A **anÃ¡lise empÃ­rica da atuaÃ§Ã£o judicial** permite discutir atÃ© que ponto **fatores pessoais**, como **idade** e **tempo de carreira**, influenciam os resultados das decisÃµes.  

Embora **correlaÃ§Ã£o nÃ£o implique causalidade**, tais estudos sÃ£o fundamentais para compreender a **diversidade de perfis decisÃ³rios** e para fomentar **polÃ­ticas de uniformizaÃ§Ã£o jurisprudencial** e **gestÃ£o da magistratura**.
:::


##  ExercÃ­cio 5 â€” **Idade x Tempo de Magistratura**

 

Dando prosseguimento ao estudo conduzido pela **equipe de pesquisa em Direito e CiÃªncia de Dados**, que tem elaborado relatÃ³rios analÃ­ticos para uma autoridade do **Tribunal de JustiÃ§a de SÃ£o Paulo (TJSP)**, o grupo decidiu agora examinar a **relaÃ§Ã£o entre a idade dos relatores e o tempo de magistratura**.  

A intenÃ§Ã£o Ã© compreender se existe **correlaÃ§Ã£o entre essas duas variÃ¡veis** â€” o que pode ajudar a **validar os dados coletados** e oferecer um retrato mais preciso do **perfil dos julgadores** que atuam nas **CÃ¢maras Criminais**.  

---  

 **Selecione apenas uma linha por relator**, contendo suas informaÃ§Ãµes de idade (`rel_idade`) e tempo de magistratura (`rel_tempo_magistratura`).  
 Crie um **grÃ¡fico de dispersÃ£o (`sns.scatterplot`)**, em que:  
   - o eixo **x** representa a idade (`rel_idade`);  
   - o eixo **y** representa o tempo de magistratura (`rel_tempo_magistratura`).  

O objetivo Ã© verificar visualmente se existe **correlaÃ§Ã£o positiva entre idade e tempo de magistratura** â€” hipÃ³tese que validaria a consistÃªncia dos dados.

---


```{pyodide}
#| exercise: ex_5
#| envir: myenv

# CARREGA OS DADOS DENTRO DO BLOCO DO EXERCÃCIO
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().replace(" ", "_") for c in camaras.columns]

# --- Escreva sua soluÃ§Ã£o aqui ---
```

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 1
Use `drop_duplicates('relator')` para garantir **apenas uma linha por relator** no DataFrame.
:::
:::

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 2 
Monte o grÃ¡fico com `sns.scatterplot()`, definindo `x='rel_idade'` e `y='rel_tempo_magistratura'`.  
Isso criarÃ¡ um **grÃ¡fico de dispersÃ£o** que permite observar a correlaÃ§Ã£o entre idade e tempo de carreira.
:::
:::

::: { .solution exercise="ex_5" }
::: { .callout-tip collapse="false" }
## SoluÃ§Ã£o
```python
relatores = camaras.drop_duplicates('relator')  # Uma linha por relator
sns.scatterplot(
    data=relatores,
    x='rel_idade',
    y='rel_tempo_magistratura'
)
plt.title("CorrelaÃ§Ã£o entre Idade e Tempo de Magistratura (TJSP)", fontsize=12)
plt.xlabel("Idade do Relator")
plt.ylabel("Tempo de Magistratura (anos)")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_5
#| check: true
#| envir: myenv

feedback = None
result = None 
try:
Â  Â  # Captura a variÃ¡vel de resposta do aluno
Â  Â  result = relatores
Â  Â  
Â  Â  # RE-CARREGA OS DADOS PARA CRIAR A RESPOSTA ESPERADA
Â  Â  url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
Â  Â  camaras = pd.read_csv(url, dtype=str)
Â  Â  camaras.columns = [c.strip().replace(" ", "_") for c in camaras.columns]
Â  Â  relatores_esperado = camaras.drop_duplicates('relator')
Â  Â  
Â  Â  if isinstance(result, pd.DataFrame):
Â  Â  Â  Â  if {'rel_idade','rel_tempo_magistratura'}.issubset(result.columns):
Â  Â  Â  Â  Â  Â  # Checagem simples
Â  Â  Â  Â  Â  Â  feedback = {"correct": True, "message": "Excelente ğŸ‰ â€” relaÃ§Ã£o entre idade e tempo de magistratura identificada corretamente!"}
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  feedback = {"correct": False, "message": "O DataFrame deve conter as colunas 'rel_idade' e 'rel_tempo_magistratura'."}
Â  Â  else:
Â  Â  Â  Â  feedback = {"correct": False, "message": "Retorne o DataFrame (relatores) antes do grÃ¡fico para validaÃ§Ã£o."}

except NameError:
Â  Â  feedback = {"correct": False, "message": "A variÃ¡vel 'relatores' nÃ£o foi encontrada."}
except Exception as e:
Â  Â  feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="âš–ï¸"}
### RelevÃ¢ncia jurÃ­dica  

O **cruzamento entre idade e tempo de magistratura** Ã© Ãºtil nÃ£o apenas para a **validaÃ§Ã£o dos dados**, mas tambÃ©m para refletir sobre **trajetÃ³rias profissionais** e a formaÃ§Ã£o de **cultura institucional** dentro do **Poder JudiciÃ¡rio**.  

Ao compreender o **perfil de carreira dos relatores**, a equipe pode investigar com mais profundidade como a **experiÃªncia influencia padrÃµes decisÃ³rios** e a **estabilidade jurisprudencial**.
:::



