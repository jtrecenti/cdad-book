---
title: Exercícios 
format: live-html
pyodide:
  packages:
    - pandas
    - matplotlib
    - seaborn
---


```{pyodide}
#| exercise: 
#|   - ex_1
#|   - ex_1_1
#|   - ex_2
#|   - ex_3
#|   - ex_4
#|   - ex_5
#| setup: true

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

URL_CAMARAS = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(URL_CAMARAS, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]

# IMPORTANTE: Marca explicitamente que o setup foi concluído
globals()['__setup_done__'] = True
globals()['camaras'] = camaras
globals()['URL_CAMARAS'] = URL_CAMARAS

```



## Exercício 1 — **Panorama de Decisões**
 
Uma autoridade do **Tribunal de Justiça de São Paulo (TJSP)** solicitou um relatório preliminar que apresente um panorama geral das decisões proferidas nas **Câmaras Criminais**.  

O objetivo é compreender a **distribuição das decisões** conforme o tipo de provimento concedido — se os recursos foram **negados**, **providos**, **parcialmente providos** ou se houve **extinção da punibilidade**.  

Esse levantamento servirá como base para um **estudo comparativo futuro** entre o TJSP e outros tribunais estaduais, buscando identificar possíveis **padrões de julgamento** e **variações na aplicação de precedentes**.  

***

Utilizando a base de dados `camaras`, elabore um **resumo quantitativo das decisões**, agrupando-as por **tipo de decisão**.  

```{pyodide}
#| exercise: ex_1

# Exercício 1 — panorama de decisões

# Crie um DataFrame chamado `total_decisoes`

```

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 1
Use `camaras["decisao"].value_counts()` para contar quantas vezes cada tipo de decisão aparece na base.
:::
:::

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 2
 Depois de obter a contagem, transforme o resultado em um **DataFrame** usando  `.reset_index(name="qtd_decisoes")`  
e **renomeie a coluna** `"index"` para `"decisao"` com: `total_decisoes = total_decisoes.rename(columns={"index": "decisao"})`.  

Por fim, use `.reset_index(drop=True)` para garantir que os índices fiquem limpos antes de retornar o DataFrame.
:::
:::

::: { .solution exercise="ex_1" }
::: { .callout-tip collapse="false" }
## Solução
```python
total_decisoes = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes")
total_decisoes = total_decisoes.rename(columns={"index": "decisao"})
total_decisoes
```
:::
:::

```{pyodide}
#| exercise: ex_1
#| check: true

# Checador automático — compara o resultado do aluno com o DataFrame esperado.
import pandas as pd
feedback = None
try:
    # tenta obter a variável por nome
    result = globals().get("total_decisoes", None)
    # fallback: procura qualquer DataFrame com colunas compatíveis
    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower().replace(" ", "_") for c in val.columns}
                if {"decisao", "qtd_decisoes"}.issubset(cols):
                    result = val
                    break

    cam = pd.read_csv(URL_CAMARAS, dtype=str)
    cam.columns = [c.strip().lower().replace(" ", "_") for c in cam.columns]
    expected = (
        cam["decisao"]
        .value_counts()
        .reset_index(name="qtd_decisoes")
        .rename(columns={"index": "decisao"})
        .reset_index(drop=True)
    )

    if result is None:
        feedback = {"correct": False, "message": "Não encontrei `total_decisoes`. Certifique-se de definir essa variável."}
    else:
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        if {"decisao", "qtd_decisoes"}.issubset(set(res.columns)):
            left = res[["decisao", "qtd_decisoes"]].copy()
            left["decisao"] = left["decisao"].astype(str).str.strip()
            left = left.sort_values("decisao").reset_index(drop=True)

            right = expected.copy()
            right["decisao"] = right["decisao"].astype(str).str.strip()
            right = right.sort_values("decisao").reset_index(drop=True)

            left["qtd_decisoes"] = pd.to_numeric(left["qtd_decisoes"], errors="coerce").fillna(0).astype(int)
            right["qtd_decisoes"] = pd.to_numeric(right["qtd_decisoes"], errors="coerce").fillna(0).astype(int)

            if left.equals(right):
                feedback = {"correct": True, "message": "Perfeito 🎉 — seu resumo de decisões está correto!"}
            else:
                merged = pd.merge(left, right, on="decisao", how="outer", suffixes=("_res", "_exp")).fillna(0)
                diffs = merged[merged["qtd_decisoes_res"] != merged["qtd_decisoes_exp"]]
                if not diffs.empty:
                    msg = "Contagens diferentes para alguns tipos (exemplo):\n" + diffs.head(6).to_csv(index=False)
                    feedback = {"correct": False, "message": msg}
                else:
                    feedback = {"correct": False, "message": "Colunas corretas, mas valores/formatos diferem. Verifique limpeza e tipos."}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter as colunas 'decisao' e 'qtd_decisoes'."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {type(e).__name__}: {e}"}

feedback
```

### Exercício 1.1 — **Visualização do Panorama de Decisões**

A autoridade responsável avaliou o relatório preliminar e solicitou que os resultados fossem apresentados de forma **mais visual**, para facilitar a compreensão em reuniões e apresentações públicas.  

Ela pediu que você **represente graficamente** a quantidade de decisões por tipo de provimento, a fim de destacar de maneira intuitiva **quais tipos de decisão são mais comuns**.  

---

Com base no DataFrame `total_decisoes`, elabore um **gráfico de barras horizontais** que mostre a quantidade de decisões em cada categoria.  


```{pyodide}
#| exercise: ex_1_1

# Use total_decisoes para criar o gráfico (y='decisao', x='qtd_decisoes')

```

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 1  
O DataFrame `total_decisoes` já contém as colunas `decisao` e `qtd_decisoes`.  
Use `sns.barplot()` para representar visualmente os valores.
:::
:::

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 2
Defina `y="decisao"` e `x="qtd_decisoes"` para gerar um gráfico de barras horizontais.  
A cor pode ser escolhida com `color="royalblue"`.
:::
:::

::: { .solution exercise="ex_1_1" }
::: { .callout-tip collapse="false" }
## Solução
```python
sns.barplot(
    data=total_decisoes,
    y="decisao",
    x="qtd_decisoes",
    color="royalblue"
)
plt.title("Distribuição das Decisões por Tipo de Provimento", fontsize=12)
plt.xlabel("Quantidade de Decisões")
plt.ylabel("Tipo de Decisão")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_1_1
#| check: true

# Checador automático — verifica se o gráfico foi gerado a partir do DataFrame correto.
feedback = None
try:
    if "total_decisoes" in globals():
        td = globals()["total_decisoes"]
        cols = {c.lower().replace(" ", "_") for c in td.columns}
        if {"decisao", "qtd_decisoes"}.issubset(cols):
            feedback = {"correct": True, "message": "Perfeito 🎉 — gráfico criado com base em total_decisoes!"}
        else:
            feedback = {"correct": False, "message": "O DataFrame total_decisoes deve conter as colunas 'decisao' e 'qtd_decisoes'."}
    else:
        feedback = {"correct": False, "message": "Certifique-se de usar o DataFrame total_decisoes gerado no exercício anterior."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="⚖️"}
### Relevância jurídica  

A **visualização de dados** é uma ferramenta poderosa para a **gestão judiciária** e para a **pesquisa empírica do Direito**. Gráficos simples podem revelar padrões que passam despercebidos em planilhas — como a **frequência de negativas de provimento** ou a **raridade de determinadas decisões**.
:::


## Exercício 2 — **Distribuição de Decisões por Câmara**

Em seguida, vamos supor que a mesma autoridade tenha solicitado uma **análise complementar** com o objetivo de verificar a **quantidade de decisões proferidas por cada Câmara** do **Tribunal de Justiça de São Paulo (TJSP)**.  

Como essa apresentação será encaminhada para um **congresso dedicado ao estudo da distribuição de decisões entre as Câmaras**, optou-se por representar os resultados em **formato gráfico**, de modo a proporcionar uma visualização mais clara, comparativa e intuitiva do volume de decisões analisadas.  

---

Utilizando a base `camaras`, elabore um **gráfico de barras** que mostre a quantidade total de decisões por **Câmara** (`camara`).  

```{pyodide}
#| exercise: ex_2


# Prepara a base 'camaras' para este exercício (o setup global já carregou a base)
# Escreva sua solução aqui:
# Agrupe por 'camara' e conte as decisões.
# Gere um gráfico de barras (horizontal) com seaborn.

```

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 1
Use `value_counts()` para contar quantas decisões há em cada Câmara.
:::
:::

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 2 
Para visualizar, use `sns.barplot()` com `x='qtd_decisoes'`, `y='camara'` e uma cor (`color='royalblue'`).
:::
:::

::: { .solution exercise="ex_2" }
::: { .callout-tip collapse="false" }
## Solução
```python
total_decisoes_por_camara = camaras["camara"].value_counts().reset_index(name="qtd_decisoes")
sns.barplot(data=total_decisoes_por_camara, y="camara", x="qtd_decisoes", color="royalblue")
plt.title("Decisões por Câmara")
plt.xlabel("Quantidade")
plt.ylabel("Câmara")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_2
#| check: true

feedback = None
try:
    result = globals().get("total_decisoes_por_camara", None)
    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower().replace(" ", "_") for c in val.columns}
                if {"camara", "qtd_decisoes"}.issubset(cols):
                    result = val
                    break

    cam = pd.read_csv(URL_CAMARAS, dtype=str)
    cam.columns = [c.strip().lower().replace(" ", "_") for c in cam.columns]
    expected = (
        cam["camara"]
        .value_counts()
        .reset_index(name="qtd_decisoes")
        .rename(columns={"index": "camara"})
        .reset_index(drop=True)
    )

    if result is None:
        feedback = {"correct": False, "message": "Não encontrei `total_decisoes_por_camara`."}
    else:
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        if {"camara", "qtd_decisoes"}.issubset(set(res.columns)):
            left = res[["camara", "qtd_decisoes"]].copy()
            left["camara"] = left["camara"].astype(str).str.strip()
            left = left.sort_values("camara").reset_index(drop=True)

            right = expected.copy()
            right["camara"] = right["camara"].astype(str).str.strip()
            right = right.sort_values("camara").reset_index(drop=True)

            left["qtd_decisoes"] = pd.to_numeric(left["qtd_decisoes"], errors="coerce").fillna(0).astype(int)
            right["qtd_decisoes"] = pd.to_numeric(right["qtd_decisoes"], errors="coerce").fillna(0).astype(int)

            if left.equals(right):
                feedback = {"correct": True, "message": "Perfeito 🎉 — gráfico e tabela de decisões por Câmara estão corretos!"}
            else:
                feedback = {"correct": False, "message": "A contagem não bate com o esperado. Verifique se usou value_counts()."}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter colunas 'camara' e 'qtd_decisoes'."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="⚖️"}
### Relevância jurídica  

A realização desse tipo de **análise é especialmente relevante para o profissional do Direito**, porque promove uma **compreensão empírica e quantitativa da atuação jurisdicional**.  

Ao examinar a **distribuição de decisões entre as Câmaras**, o operador do Direito pode identificar **padrões de produtividade, especialização e volume de demandas** — elementos essenciais para a **gestão judiciária eficiente** e para o **aperfeiçoamento das políticas públicas de justiça**.
:::


## Exercício 3 — **Padrão Decisório Comparado**

Uma equipe de pesquisa da **Escola da Magistratura** está conduzindo um estudo sobre **padrões de decisão entre diferentes relatores** das **Câmaras Criminais do TJSP**.  

O objetivo é verificar se existem **diferenças perceptíveis no comportamento decisório** de magistrados — por exemplo, se um relator tende a negar mais recursos do que outro, ou se há maior propensão a decisões **parcialmente providas**.  

Para iniciar o estudo, a equipe selecionou dois relatores com grande volume de decisões no acervo:  

- **Mário Devienne Ferraz**  
- **Alberto Anderson Filho**

O foco é **comparar o perfil decisório** desses dois magistrados quanto à variável **"decisão"**, que representa o resultado do julgamento do recurso.  

---

Filtre a base `camaras` para manter **somente as decisões** proferidas pelos relatores acima e salvar o resultado em `rel_comparacao` e utilize o Seaborn para **criar um gráfico de barras horizontais** que compare a quantidade de decisões de cada tipo (`DECISAO`) entre os dois relatores.  
A ideia é gerar barras agrupadas por `DECISAO` com `hue` indicando o `RELATOR`.

```{pyodide}
#| exercise: ex_3

# CARREGA OS DADOS E FORMATA EM MAIÚSCULO
camaras_upper = camaras.copy()
for col in camaras_upper.columns:
    camaras_upper[col] = camaras_upper[col].astype(str).str.upper().str.strip()
camaras_upper.columns = [c.strip().upper().replace(" ", "_") for c in camaras_upper.columns]

# --- Escreva sua solução aqui ---

```

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 1 
Crie uma lista com os dois nomes de relatores e use `query('RELATOR == @rel_comparacao')` para filtrar a base.
:::
:::

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 2
Para o gráfico, use `sns.countplot()` e mapeie `y='RELATOR'`, `hue='DECISAO'` e `palette='flare'`.
:::
:::

::: { .solution exercise="ex_3" }
::: { .callout-tip collapse="false" }
## Solução
```python
rel_comparacao_nomes = ['MÁRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO']
rel_comparacao = camaras_upper[camaras_upper['RELATOR'].isin(rel_comparacao_nomes)]

sns.countplot(
    data=rel_comparacao,
    y='RELATOR',
    hue='DECISAO',
    palette='flare'
)
plt.title("Padrão Decisório Comparado — TJSP", fontsize=12)
plt.xlabel("Quantidade de Decisões")
plt.ylabel("Relator")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_3
#| check: true
#| envir: myenv

feedback = None
try:
    result = globals().get("rel_comparacao", None)

    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.upper().replace(" ", "_") for c in val.columns}
                if 'RELATOR' in cols and any('DECISAO' in c or 'DECISãO' in c for c in cols):
                    result = val
                    break

    if result is None:
        feedback = {
            "correct": False,
            "message": "Não encontrei o DataFrame `rel_comparacao`. Certifique-se de filtrá-lo criando `rel_comparacao`."
        }
    else:
        cols_norm = {c.upper().replace(" ", "_") for c in result.columns}

        has_relator = 'RELATOR' in cols_norm
        has_decisao = any('DECISAO' in c or 'DECIS' in c for c in cols_norm)

        if not has_relator or not has_decisao:
            faltando = []
            if not has_relator:
                faltando.append("'RELATOR'")
            if not has_decisao:
                faltando.append("'DECISAO' (ou coluna similar)")
            feedback = {
                "correct": False,
                "message": f"Seu DataFrame foi encontrado, mas faltam colunas esperadas: {', '.join(faltando)}."
            }
        else:
            relatores_presentes = sorted({str(v).strip().upper() for v in result['RELATOR'].astype(str).unique()})
            esperado = {'MÁRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO'}
            intersec = esperado.intersection(set(relatores_presentes))
            if len(intersec) == len(esperado):
                feedback = {"correct": True, "message": "Excelente — filtrou corretamente os dois relatores!"}
            elif len(intersec) > 0:
                feedback = {"correct": False, "message": "Encontrou alguns relatores, mas não todos os esperados. Verifique nomes/acentuação."}
            else:
                feedback = {"correct": False, "message": "O DataFrame não contém os relatores esperados. Verifique a filtragem (nomes/acentuação)."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {type(e).__name__}: {e}"}

feedback

```

::: {.callout-tip icon="⚖️"}
### Relevância jurídica  

**Comparar padrões decisórios entre relatores** é uma técnica frequentemente utilizada em estudos de **Direito e Tecnologia**.  
Essa abordagem permite investigar a **consistência e previsibilidade das decisões judiciais**, bem como discutir o papel da **subjetividade judicial** no contexto dos tribunais.
:::


## Exercício 4 — **Idade x Padrão Decisório**

Dando sequência ao estudo desenvolvido pela **equipe de pesquisa em Direito e Ciência de Dados**, que vem atendendo às solicitações de uma autoridade do **Tribunal de Justiça de São Paulo (TJSP)**, surge uma nova questão de interesse.  

Após observar **diferenças de comportamento entre relatores** nas análises anteriores, a equipe foi instigada a investigar se a **idade dos magistrados pode estar relacionada ao tipo de decisão proferida**.  

A hipótese é de que **relatores mais experientes** — e, portanto, com **maior idade** — possam apresentar **tendências distintas** em relação à concessão ou negação de recursos.  

O objetivo deste exercício é verificar se há alguma **correlação entre a idade dos relatores e o padrão de decisões proferidas**.  

Crie tabelas que permitam comparar a idade dos relatores com a **quantidade de decisões de cada tipo**.  
A autoridade do TJSP solicitou que a equipe apresentasse uma **visualização gráfica** que pudesse indicar se existe **relação entre a idade dos relatores e o número de decisões negativas ("Negaram")**.  

O objetivo é observar possíveis **tendências etárias no comportamento decisório** das Câmaras Criminais.  

---

Crie uma tabela com o número de decisões de cada tipo por relator.  
Crie outra tabela com a idade de cada relator (`rel_idade`).  
Faça um **merge** das duas tabelas, resultando em `decisoes_idade`.  
Elabore um **gráfico de dispersão (`sns.scatterplot`)** mostrando `rel_idade` (x) versus o número de decisões "Negaram" (y).

```{pyodide}
#| exercise: ex_4

# CARREGA OS DADOS DENTRO DO BLOCO DO EXERCÍCIO (setup já carregou a base)
# --- Escreva sua solução aqui ---

```

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 1  
Use `groupby(['relator','decisao']).size().unstack(fill_value=0)` para montar a tabela de decisões por relator.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 2 
Para associar a idade de cada relator, remova duplicatas (`drop_duplicates('relator')`) e selecione `['relator','rel_idade']`.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 3
Depois, use `pd.merge()` para juntar as duas tabelas e gere o gráfico de dispersão (`sns.scatterplot`).
:::
:::

::: { .solution exercise="ex_4" }
::: { .callout-tip collapse="false" }

##  Solução

```python
# TABELA DE TIPO DE DECISÕES POR RELATOR 
decisoes_relator = camaras.groupby(['relator', 'decisao']).size().unstack(fill_value=0)

# Capitaliza os nomes das colunas para garantir "Negaram"
decisoes_relator.columns = [c.capitalize() for c in decisoes_relator.columns]
decisoes_relator = decisoes_relator.reset_index()

# TABELA DE IDADES POR RELATOR 
idade_relator = camaras.drop_duplicates('relator')[['relator', 'rel_idade']]

# JUNÇÃO DA IDADE COM AS DECISÕES
decisoes_idade = pd.merge(decisoes_relator, idade_relator, on='relator')

# Converte idade para numérico
decisoes_idade['rel_idade'] = pd.to_numeric(decisoes_idade['rel_idade'], errors='coerce')

# GRÁFICO DE DISPERSÃO
if 'Negaram' in decisoes_idade.columns:
    sns.scatterplot(data=decisoes_idade, x='rel_idade', y='Negaram')
    plt.title("Relação entre Idade e Decisões Negativas (TJSP)")
    plt.xlabel("Idade do Relator")
    plt.ylabel("Número de Decisões 'Negaram'")
    plt.tight_layout()
    plt.show()
else:
    print("⚠️ Coluna 'Negaram' não encontrada. Colunas:", decisoes_idade.columns.tolist())
```
:::
:::

```{pyodide}
#| exercise: ex_4
#| check: true

feedback = None
try:
    result = globals().get("decisoes_idade", None)
    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower().replace(" ", "_") for c in val.columns}
                if {"relator", "rel_idade"}.issubset(cols) and any("negar" in c.lower() for c in val.columns):
                    result = val
                    break

    cam = pd.read_csv(URL_CAMARAS, dtype=str)
    cam.columns = [c.strip().lower().replace(" ", "_") for c in cam.columns]

    if result is None:
        feedback = {"correct": False, "message": "Não encontrei `decisoes_idade`."}
    else:
        # Verifica se tem as colunas necessárias (case insensitive)
        cols_lower = {c.lower() for c in result.columns}
        has_relator = 'relator' in cols_lower
        has_idade = 'rel_idade' in cols_lower
        has_negaram = any('negar' in c.lower() for c in result.columns)
        
        if has_relator and has_idade and has_negaram:
            feedback = {"correct": True, "message": "Perfeito 🎉 — você combinou corretamente as tabelas e gerou a base para o gráfico!"}
        else:
            faltando = []
            if not has_relator: faltando.append("relator")
            if not has_idade: faltando.append("rel_idade")
            if not has_negaram: faltando.append("coluna com 'Negaram'")
            feedback = {"correct": False, "message": f"Faltam: {', '.join(faltando)}. Verifique a junção."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

##  Exercício 5 — **Idade x Tempo de Magistratura**

Dando prosseguimento ao estudo conduzido pela **equipe de pesquisa em Direito e Ciência de Dados**, que tem elaborado relatórios analíticos para uma autoridade do **Tribunal de Justiça de São Paulo (TJSP)**, o grupo decidiu agora examinar a **relação entre a idade dos relatores e o tempo de magistratura**.  

A intenção é compreender se existe **correlação entre essas duas variáveis** — o que pode ajudar a **validar os dados coletados** e oferecer um retrato mais preciso do **perfil dos julgadores** que atuam nas **Câmaras Criminais**.  

---  

 **Selecione apenas uma linha por relator**, contendo suas informações de idade (`rel_idade`) e tempo de magistratura (`rel_tempo_magistratura`).  
 Crie um **gráfico de dispersão (`sns.scatterplot`)**, em que:  
   - o eixo **x** representa a idade (`rel_idade`);  
   - o eixo **y** representa o tempo de magistratura (`rel_tempo_magistratura`).  

O objetivo é verificar visualmente se existe **correlação positiva entre idade e tempo de magistratura** — hipótese que validaria a consistência dos dados.

```{pyodide}
#| exercise: ex_5


# CARREGA OS DADOS DENTRO DO BLOCO DO EXERCÍCIO (setup já carregou a base)
# --- Escreva sua solução aqui ---

```

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 1
Use `drop_duplicates('relator')` para garantir **apenas uma linha por relator** no DataFrame.
:::
:::

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 2 
Monte o gráfico com `sns.scatterplot()`, definindo `x='rel_idade'` e `y='rel_tempo_magistratura'`.  
Isso criará um **gráfico de dispersão** que permite observar a correlação entre idade e tempo de carreira.
:::
:::

::: { .solution exercise="ex_5" }
::: { .callout-tip collapse="false" }

## Solução

```python
relatores = camaras.drop_duplicates('relator')[['relator', 'rel_idade', 'rel_tempo_magistratura']]

# Converte para numérico
relatores['rel_idade'] = pd.to_numeric(relatores['rel_idade'], errors='coerce')
relatores['rel_tempo_magistratura'] = pd.to_numeric(relatores['rel_tempo_magistratura'], errors='coerce')

sns.scatterplot(
    data=relatores,
    x='rel_idade',
    y='rel_tempo_magistratura'
)
plt.title("Correlação entre Idade e Tempo de Magistratura (TJSP)", fontsize=12)
plt.xlabel("Idade do Relator")
plt.ylabel("Tempo de Magistratura (anos)")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_5
#| check: true

feedback = None
try:
    result = globals().get("relatores", None)
    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower().replace(" ", "_") for c in val.columns}
                if {"rel_idade", "rel_tempo_magistratura"}.issubset(cols):
                    result = val
                    break

    cam = pd.read_csv(URL_CAMARAS, dtype=str)
    cam.columns = [c.strip().lower().replace(" ", "_") for c in cam.columns]
    relatores_esperado = cam.drop_duplicates('relator')

    if result is None:
        feedback = {"correct": False, "message": "Não encontrei o DataFrame de relatores (uma linha por relator). Nome sugerido: `relatores`."}
    else:
        cols = {c.lower().replace(" ", "_") for c in result.columns}
        if {"rel_idade", "rel_tempo_magistratura"}.issubset(cols):
            feedback = {"correct": True, "message": "Excelente 🎉 — relação entre idade e tempo de magistratura identificada corretamente!"}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter 'rel_idade' e 'rel_tempo_magistratura'."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="⚖️"}
### Relevância jurídica  

A **análise da correlação entre idade e tempo de magistratura** permite não apenas **validar a qualidade dos dados**, mas também compreender melhor o **perfil dos magistrados** que compõem as **Câmaras Criminais**.  

Essa investigação pode revelar padrões de **progressão na carreira** e oferecer subsídios para **políticas de formação continuada** e **gestão de recursos humanos** no Poder Judiciário.
:::