---
title: Exerc√≠cios 
format: live-html
pyodide:
  packages:
    - pandas
    - matplotlib
    - seaborn
    - scikit-learn
    - numpy
    - warnings
    - statsmodels
---


```{pyodide}
#| exercise: 
#|   - ex_1
#|   - ex_1_1
#|   - ex_2
#|   - ex_3
#|   - ex_4
#|   - ex_5
#|   - ex_6
#|   - ex_7
#|   - ex_8
#|   - ex_9
#|   - ex_10
#|   - ex_11
#|   - ex_12
#| setup: true

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# URLs
URL_CAMARAS = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
URL_VIVO = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/vivo.csv"

# Carrega dados
camaras = pd.read_csv(URL_CAMARAS, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]

vivo = pd.read_csv(URL_VIVO)

# pequenas transforma√ß√µes √∫teis (sem resolver exerc√≠cios)
total_decisoes_ref = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes")
total_decisoes_ref = total_decisoes_ref.rename(columns={"index": "decisao"})

vivo_filtrado = vivo[vivo['desfecho_vivo'].isin(['Vit√≥ria', 'Derrota (Total ou Parcial)'])]
vivo_filtrado = vivo_filtrado.dropna(subset=['juiz_tempo_vara', 'pags_inicial', 'pags_contestacao'])
vivo_filtrado = vivo_filtrado.copy() # Evita SettingWithCopyWarning

# Solu√ß√£o Ex 7 (para criar 'y')
vivo['y'] = np.where(vivo['desfecho_vivo'] == 'Vit√≥ria', 1, 0)
vivo_filtrado['y'] = np.where(vivo_filtrado['desfecho_vivo'] == 'Vit√≥ria', 1, 0)

print("Setup (3/4): Vari√°veis 'vivo_filtrado' e 'y' criadas...")

# Solu√ß√£o Ex 8 (para criar 'dummies_juiz')
dummies_juiz = pd.get_dummies(vivo_filtrado['juiz'])

# Solu√ß√£o Ex 9 (para criar 'dummies_juiz_select')
frequencias = dummies_juiz.sum()
juizes_selecionados = frequencias[frequencias > 50].index
dummies_juiz_select = dummies_juiz[juizes_selecionados]

# Solu√ß√£o Ex 10 (para criar 'vivo_f', a base de modelagem)
# --- LINHA FALTANDO ADICIONADA AQUI ---
numeric_cols = ['valor', 'pags_inicial', 'pags_contestacao', 'juiz_tempo_vara']
vivo_numeric = vivo_filtrado[numeric_cols]
# --- LINHA DO 'vivo_f' MOVIDA PARA A ORDEM CORRETA ---
vivo_f = pd.concat([vivo_numeric, dummies_juiz_select], axis=1)


```



## Exerc√≠cio 1 ‚Äî **Panorama de Decis√µes**
 
Uma autoridade do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)** solicitou um relat√≥rio preliminar que apresente um panorama geral das decis√µes proferidas nas **C√¢maras Criminais**.  

O objetivo √© compreender a **distribui√ß√£o das decis√µes** conforme o tipo de provimento concedido ‚Äî se os recursos foram **negados**, **providos**, **parcialmente providos** ou se houve **extin√ß√£o da punibilidade**.  

Esse levantamento servir√° como base para um **estudo comparativo futuro** entre o TJSP e outros tribunais estaduais, buscando identificar poss√≠veis **padr√µes de julgamento** e **varia√ß√µes na aplica√ß√£o de precedentes**.  

***

Utilizando a base de dados `camaras`, elabore um **resumo quantitativo das decis√µes**, agrupando-as por **tipo de decis√£o**.  

```{pyodide}
#| exercise: ex_1

# Exerc√≠cio 1 ‚Äî panorama de decis√µes

# Crie um DataFrame chamado `total_decisoes`

```

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 1
Use `camaras["decisao"].value_counts()` para contar quantas vezes cada tipo de decis√£o aparece na base.
:::
:::

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 2
 Depois de obter a contagem, transforme o resultado em um **DataFrame** usando  `.reset_index(name="qtd_decisoes")`  
e **renomeie a coluna** `"index"` para `"decisao"` com: `total_decisoes = total_decisoes.rename(columns={"index": "decisao"})`.  

Por fim, use `.reset_index(drop=True)` para garantir que os √≠ndices fiquem limpos antes de retornar o DataFrame.
:::
:::

::: { .solution exercise="ex_1" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
total_decisoes = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes")
total_decisoes = total_decisoes.rename(columns={"index": "decisao"})
total_decisoes
```
:::
:::

```{pyodide}
#| exercise: ex_1
#| check: true
import pandas as pd
feedback = None
try:
    result = globals().get("total_decisoes", None)
    # busca alternativa: qualquer DataFrame com colunas compat√≠veis
    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower().replace(" ", "_") for c in val.columns}
                if {"decisao", "qtd_decisoes"}.issubset(cols):
                    result = val
                    break

    if result is None:
        feedback = {"correct": False, "message": "N√£o encontrei `total_decisoes`. Defina essa vari√°vel (DataFrame)."}
    elif not isinstance(result, pd.DataFrame):
        feedback = {"correct": False, "message": f"`total_decisoes` existe mas n√£o √© DataFrame (type={type(result).__name__})."}
    else:
        # normaliza colunas
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        if {"decisao", "qtd_decisoes"}.issubset(set(res.columns)):
            # prepara esperado
            cam = pd.read_csv(URL_CAMARAS, dtype=str)
            cam.columns = [c.strip().lower().replace(" ", "_") for c in cam.columns]
            expected = (cam["decisao"].value_counts().reset_index(name="qtd_decisoes")
                        .rename(columns={"index":"decisao"}).reset_index(drop=True))
            left = res[["decisao", "qtd_decisoes"]].copy()
            left["decisao"] = left["decisao"].astype(str).str.strip()
            left["qtd_decisoes"] = pd.to_numeric(left["qtd_decisoes"], errors="coerce").fillna(0).astype(int)
            right = expected.copy()
            right["decisao"] = right["decisao"].astype(str).str.strip()
            right["qtd_decisoes"] = pd.to_numeric(right["qtd_decisoes"], errors="coerce").fillna(0).astype(int)
            merged = pd.merge(left, right, on="decisao", how="outer", suffixes=("_res","_exp")).fillna(0)
            diffs = merged[merged["qtd_decisoes_res"] != merged["qtd_decisoes_exp"]]
            if diffs.empty and len(left)>0:
                feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî seu resumo de decis√µes est√° correto!"}
            else:
                # mostra exemplo de diferen√ßa
                sample = diffs.head(6).to_csv(index=False)
                feedback = {"correct": False, "message": "Diferen√ßas nas contagens (exemplo):\n" + sample}
        else:
            feedback = {"correct": False, "message": "Colunas esperadas: 'decisao' e 'qtd_decisoes' (verifique nomes)."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {type(e).__name__}: {e}"}
feedback
```

### Exerc√≠cio 1.1 ‚Äî **Visualiza√ß√£o do Panorama de Decis√µes**

A autoridade respons√°vel avaliou o relat√≥rio preliminar e solicitou que os resultados fossem apresentados de forma **mais visual**, para facilitar a compreens√£o em reuni√µes e apresenta√ß√µes p√∫blicas.  

Ela pediu que voc√™ **represente graficamente** a quantidade de decis√µes por tipo de provimento, a fim de destacar de maneira intuitiva **quais tipos de decis√£o s√£o mais comuns**.  

---

Com base no DataFrame `total_decisoes`, elabore um **gr√°fico de barras horizontais** que mostre a quantidade de decis√µes em cada categoria.  


```{pyodide}
#| exercise: ex_1_1
total_decisoes = total_decisoes_ref.copy() # apenas carregando a vari√°vel para o exerc√≠cio

# Use total_decisoes para criar o gr√°fico (y='decisao', x='qtd_decisoes')

```

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 1  
O DataFrame `total_decisoes` j√° cont√©m as colunas `decisao` e `qtd_decisoes`.  
Use `sns.barplot()` para representar visualmente os valores.
:::
:::

::: { .hint exercise="ex_1_1" }
::: { .callout-note collapse="false" }
## Dica 2
Defina `y="decisao"` e `x="qtd_decisoes"` para gerar um gr√°fico de barras horizontais.  
A cor pode ser escolhida com `color="royalblue"`.
:::
:::

::: { .solution exercise="ex_1_1" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
sns.barplot(
    data=total_decisoes,
    y="decisao",
    x="qtd_decisoes",
    color="royalblue"
)
plt.title("Distribui√ß√£o das Decis√µes por Tipo de Provimento", fontsize=12)
plt.xlabel("Quantidade de Decis√µes")
plt.ylabel("Tipo de Decis√£o")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_1_1
#| check: true
import pandas as pd
feedback = None
try:
    td = globals().get("total_decisoes", None)
    if td is None or not isinstance(td, pd.DataFrame):
        feedback = {"correct": False, "message": "N√£o encontrei um DataFrame `total_decisoes`. Gere-o antes do gr√°fico."}
    else:
        cols = {c.lower().replace(" ", "_") for c in td.columns}
        if {"decisao", "qtd_decisoes"}.issubset(cols):
            feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî gr√°fico criado com base em total_decisoes!"}
        else:
            feedback = {"correct": False, "message": "O DataFrame `total_decisoes` deve conter 'decisao' e 'qtd_decisoes'."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback

```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A **visualiza√ß√£o de dados** √© uma ferramenta poderosa para a **gest√£o judici√°ria** e para a **pesquisa emp√≠rica do Direito**. Gr√°ficos simples podem revelar padr√µes que passam despercebidos em planilhas ‚Äî como a **frequ√™ncia de negativas de provimento** ou a **raridade de determinadas decis√µes**.
:::


## Exerc√≠cio 2 ‚Äî **Distribui√ß√£o de Decis√µes por C√¢mara**

Em seguida, vamos supor que a mesma autoridade tenha solicitado uma **an√°lise complementar** com o objetivo de verificar a **quantidade de decis√µes proferidas por cada C√¢mara** do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)**.  

Como essa apresenta√ß√£o ser√° encaminhada para um **congresso dedicado ao estudo da distribui√ß√£o de decis√µes entre as C√¢maras**, optou-se por representar os resultados em **formato gr√°fico**, de modo a proporcionar uma visualiza√ß√£o mais clara, comparativa e intuitiva do volume de decis√µes analisadas.  

---

Utilizando a base `camaras`, elabore um **gr√°fico de barras** que mostre a quantidade total de decis√µes por **C√¢mara** (`camara`).  

```{pyodide}
#| exercise: ex_2


```

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 1
Use `value_counts()` para contar quantas decis√µes h√° em cada C√¢mara.
:::
:::

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
## Dica 2 
Para visualizar, use `sns.barplot()` com `x='qtd_decisoes'`, `y='camara'` e uma cor (`color='royalblue'`).
:::
:::

::: { .solution exercise="ex_2" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
total_decisoes_por_camara = camaras["camara"].value_counts().reset_index(name="qtd_decisoes")
sns.barplot(data=total_decisoes_por_camara, y="camara", x="qtd_decisoes", color="royalblue")
plt.title("Decis√µes por C√¢mara")
plt.xlabel("Quantidade")
plt.ylabel("C√¢mara")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_2
#| check: true
import pandas as pd
feedback = None
try:
    res = globals().get("total_decisoes_por_camara", None)
    if res is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower().replace(" ", "_") for c in val.columns}
                if {"camara", "qtd_decisoes"}.issubset(cols):
                    res = val
                    break
    if res is None:
        feedback = {"correct": False, "message": "N√£o encontrei `total_decisoes_por_camara`."}
    elif not isinstance(res, pd.DataFrame):
        feedback = {"correct": False, "message": f"`total_decisoes_por_camara` existe mas n√£o √© DataFrame (type={type(res).__name__})."}
    else:
        df = res.rename(columns={c: c.lower().replace(" ", "_") for c in res.columns})
        if {"camara", "qtd_decisoes"}.issubset(set(df.columns)):
            cam = pd.read_csv(URL_CAMARAS, dtype=str)
            cam.columns = [c.strip().lower().replace(" ", "_") for c in cam.columns]
            expected = (cam["camara"].value_counts().reset_index(name="qtd_decisoes").rename(columns={"index":"camara"}).reset_index(drop=True))
            left = df[["camara","qtd_decisoes"]].copy()
            left["camara"] = left["camara"].astype(str).str.strip()
            left["qtd_decisoes"] = pd.to_numeric(left["qtd_decisoes"], errors="coerce").fillna(0).astype(int)
            right = expected.copy()
            right["camara"] = right["camara"].astype(str).str.strip()
            right["qtd_decisoes"] = pd.to_numeric(right["qtd_decisoes"], errors="coerce").fillna(0).astype(int)
            merged = pd.merge(left,right,on="camara",how="outer",suffixes=("_res","_exp")).fillna(0)
            diffs = merged[merged["qtd_decisoes_res"] != merged["qtd_decisoes_exp"]]
            if diffs.empty:
                feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî gr√°fico e tabela de decis√µes por C√¢mara est√£o corretos!"}
            else:
                feedback = {"correct": False, "message": "Contagens diferentes para algumas C√¢maras (verifique)."}
        else:
            feedback = {"correct": False, "message": "Colunas esperadas: 'camara' e 'qtd_decisoes'."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {type(e).__name__}: {e}"}
feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A realiza√ß√£o desse tipo de **an√°lise √© especialmente relevante para o profissional do Direito**, porque promove uma **compreens√£o emp√≠rica e quantitativa da atua√ß√£o jurisdicional**.  

Ao examinar a **distribui√ß√£o de decis√µes entre as C√¢maras**, o operador do Direito pode identificar **padr√µes de produtividade, especializa√ß√£o e volume de demandas** ‚Äî elementos essenciais para a **gest√£o judici√°ria eficiente** e para o **aperfei√ßoamento das pol√≠ticas p√∫blicas de justi√ßa**.
:::


## Exerc√≠cio 3 ‚Äî **Padr√£o Decis√≥rio Comparado**

Uma equipe de pesquisa da **Escola da Magistratura** est√° conduzindo um estudo sobre **padr√µes de decis√£o entre diferentes relatores** das **C√¢maras Criminais do TJSP**.  

O objetivo √© verificar se existem **diferen√ßas percept√≠veis no comportamento decis√≥rio** de magistrados ‚Äî por exemplo, se um relator tende a negar mais recursos do que outro, ou se h√° maior propens√£o a decis√µes **parcialmente providas**.  

Para iniciar o estudo, a equipe selecionou dois relatores com grande volume de decis√µes no acervo:  

- **M√°rio Devienne Ferraz**  
- **Alberto Anderson Filho**

O foco √© **comparar o perfil decis√≥rio** desses dois magistrados quanto √† vari√°vel **"decis√£o"**, que representa o resultado do julgamento do recurso.  

---

Filtre a base `camaras` para manter **somente as decis√µes** proferidas pelos relatores acima e salvar o resultado em `rel_comparacao` e utilize o Seaborn para **criar um gr√°fico de barras horizontais** que compare a quantidade de decis√µes de cada tipo (`DECISAO`) entre os dois relatores.  
A ideia √© gerar barras agrupadas por `DECISAO` com `hue` indicando o `RELATOR`.

```{pyodide}
#| exercise: ex_3

# CARREGA OS DADOS E FORMATA EM MAI√öSCULO
camaras_upper = camaras.copy()
for col in camaras_upper.columns:
    camaras_upper[col] = camaras_upper[col].astype(str).str.upper().str.strip()
camaras_upper.columns = [c.strip().upper().replace(" ", "_") for c in camaras_upper.columns]

# --- Escreva sua solu√ß√£o aqui ---

```

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 1 
Crie uma lista com os dois nomes de relatores e use `query('RELATOR == @rel_comparacao')` para filtrar a base.
:::
:::

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 2
Para o gr√°fico, use `sns.countplot()` e mapeie `y='RELATOR'`, `hue='DECISAO'` e `palette='flare'`.
:::
:::

::: { .solution exercise="ex_3" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
rel_comparacao_nomes = ['M√ÅRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO']
rel_comparacao = camaras_upper[camaras_upper['RELATOR'].isin(rel_comparacao_nomes)]

sns.countplot(
    data=rel_comparacao,
    y='RELATOR',
    hue='DECISAO',
    palette='flare'
)
plt.title("Padr√£o Decis√≥rio Comparado ‚Äî TJSP", fontsize=12)
plt.xlabel("Quantidade de Decis√µes")
plt.ylabel("Relator")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_3
#| check: true

feedback = None
try:
    result = globals().get("rel_comparacao", None)
    if result is None:
        feedback = {"correct": False, "message": "N√£o encontrei `rel_comparacao`. Certifique-se de filtrar os relatores esperados."}
    else:
        # normaliza nomes de colunas e valores
        cols = {c.upper().replace(" ", "_") for c in result.columns}
        # garanta que a coluna RELATOR exista (case-insensitive)
        if 'RELATOR' in cols:
            # extrai os valores √∫nicos da coluna RELATOR de forma robusta
            try:
                rel_values = [str(x).strip().upper() for x in result.loc[:, result.columns.str.upper().str.replace(" ", "_") == 'RELATOR'].iloc[:,0].unique()]
            except Exception:
                # fallback simples se acesso por loc falhar
                rel_values = [str(x).strip().upper() for x in result['RELADOR'].astype(str).unique()] if 'RELADOR' in result.columns else [str(x).strip().upper() for x in result.iloc[:,0].astype(str).unique()]

            expected = {'M√ÅRIO DEVIENNE FERRAZ', 'ALBERTO ANDERSON FILHO'}
            found_set = set(rel_values)
            missing = sorted(list(expected - found_set))
            if not missing:
                feedback = {"correct": True, "message": "Excelente üéâ ‚Äî filtrou corretamente os dois relatores!"}
            else:
                feedback = {"correct": False, "message": f"Faltam relatores esperados (n√£o encontrados): {missing}. Relatores encontrados: {sorted(list(found_set))[:10]} (mostrando at√© 10)."}
        else:
            feedback = {"correct": False, "message": "Seu DataFrame precisa conter a coluna 'RELATOR' (verifique nomes e capitaliza√ß√£o)."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {type(e).__name__}: {e}"}
feedback

```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

**Comparar padr√µes decis√≥rios entre relatores** √© uma t√©cnica frequentemente utilizada em estudos de **Direito e Tecnologia**.  
Essa abordagem permite investigar a **consist√™ncia e previsibilidade das decis√µes judiciais**, bem como discutir o papel da **subjetividade judicial** no contexto dos tribunais.
:::


## Exerc√≠cio 4 ‚Äî **Idade x Padr√£o Decis√≥rio**

Dando sequ√™ncia ao estudo desenvolvido pela **equipe de pesquisa em Direito e Ci√™ncia de Dados**, que vem atendendo √†s solicita√ß√µes de uma autoridade do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)**, surge uma nova quest√£o de interesse.  

Ap√≥s observar **diferen√ßas de comportamento entre relatores** nas an√°lises anteriores, a equipe foi instigada a investigar se a **idade dos magistrados pode estar relacionada ao tipo de decis√£o proferida**.  

A hip√≥tese √© de que **relatores mais experientes** ‚Äî e, portanto, com **maior idade** ‚Äî possam apresentar **tend√™ncias distintas** em rela√ß√£o √† concess√£o ou nega√ß√£o de recursos.  

O objetivo deste exerc√≠cio √© verificar se h√° alguma **correla√ß√£o entre a idade dos relatores e o padr√£o de decis√µes proferidas**.  

Crie tabelas que permitam comparar a idade dos relatores com a **quantidade de decis√µes de cada tipo**.  
A autoridade do TJSP solicitou que a equipe apresentasse uma **visualiza√ß√£o gr√°fica** que pudesse indicar se existe **rela√ß√£o entre a idade dos relatores e o n√∫mero de decis√µes negativas ("Negaram")**.  

O objetivo √© observar poss√≠veis **tend√™ncias et√°rias no comportamento decis√≥rio** das C√¢maras Criminais.  

---

Crie uma tabela com o n√∫mero de decis√µes de cada tipo por relator.  
Crie outra tabela com a idade de cada relator (`rel_idade`).  
Fa√ßa um **merge** das duas tabelas, resultando em `decisoes_idade`.  
Elabore um **gr√°fico de dispers√£o (`sns.scatterplot`)** mostrando `rel_idade` (x) versus o n√∫mero de decis√µes "Negaram" (y).

```{pyodide}
#| exercise: ex_4

# CARREGA OS DADOS DENTRO DO BLOCO DO EXERC√çCIO (setup j√° carregou a base)
# --- Escreva sua solu√ß√£o aqui ---

```

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 1  
Use `groupby(['relator','decisao']).size().unstack(fill_value=0)` para montar a tabela de decis√µes por relator.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 2 
Para associar a idade de cada relator, remova duplicatas (`drop_duplicates('relator')`) e selecione `['relator','rel_idade']`.
:::
:::

::: { .hint exercise="ex_4" }
::: { .callout-note collapse="false" }
## Dica 3
Depois, use `pd.merge()` para juntar as duas tabelas e gere o gr√°fico de dispers√£o (`sns.scatterplot`).
:::
:::

::: { .solution exercise="ex_4" }
::: { .callout-tip collapse="false" }

##  Solu√ß√£o

```python
# TABELA DE TIPO DE DECIS√ïES POR RELATOR 
decisoes_relator = camaras.groupby(['relator', 'decisao']).size().unstack(fill_value=0)

# Capitaliza os nomes das colunas para garantir "Negaram"
decisoes_relator.columns = [c.capitalize() for c in decisoes_relator.columns]
decisoes_relator = decisoes_relator.reset_index()

# TABELA DE IDADES POR RELATOR 
idade_relator = camaras.drop_duplicates('relator')[['relator', 'rel_idade']]

# JUN√á√ÉO DA IDADE COM AS DECIS√ïES
decisoes_idade = pd.merge(decisoes_relator, idade_relator, on='relator')

# Converte idade para num√©rico
decisoes_idade['rel_idade'] = pd.to_numeric(decisoes_idade['rel_idade'], errors='coerce')

# GR√ÅFICO DE DISPERS√ÉO
if 'Negaram' in decisoes_idade.columns:
    sns.scatterplot(data=decisoes_idade, x='rel_idade', y='Negaram')
    plt.title("Rela√ß√£o entre Idade e Decis√µes Negativas (TJSP)")
    plt.xlabel("Idade do Relator")
    plt.ylabel("N√∫mero de Decis√µes 'Negaram'")
    plt.tight_layout()
    plt.show()
else:
    print("‚ö†Ô∏è Coluna 'Negaram' n√£o encontrada. Colunas:", decisoes_idade.columns.tolist())
```
:::
:::

```{pyodide}
#| exercise: ex_4
#| check: true
import pandas as pd
feedback = None
try:
    result = globals().get("decisoes_idade", None)
    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower() for c in val.columns}
                if "relator" in cols and "rel_idade" in cols and any("negar" in c for c in cols):
                    result = val
                    break
    if result is None:
        feedback = {"correct": False, "message": "N√£o encontrei `decisoes_idade`. Verifique a jun√ß√£o."}
    elif not isinstance(result, pd.DataFrame):
        feedback = {"correct": False, "message": "`decisoes_idade` existe mas n√£o √© um DataFrame."}
    else:
        cols_lower = {c.lower() for c in result.columns}
        has_negar = any("negar" in c for c in cols_lower)
        if "relator" in cols_lower and "rel_idade" in cols_lower and has_negar:
            feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî base para gr√°fico de idade est√° ok!"}
        else:
            faltam = []
            if "relator" not in cols_lower: faltam.append("relator")
            if "rel_idade" not in cols_lower: faltam.append("rel_idade")
            if not has_negar: faltam.append("coluna com 'Negaram'")
            feedback = {"correct": False, "message": "Faltam: " + ", ".join(faltam)}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```




##  Exerc√≠cio 5 ‚Äî **Idade x Tempo de Magistratura**

Dando prosseguimento ao estudo conduzido pela **equipe de pesquisa em Direito e Ci√™ncia de Dados**, que tem elaborado relat√≥rios anal√≠ticos para uma autoridade do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)**, o grupo decidiu agora examinar a **rela√ß√£o entre a idade dos relatores e o tempo de magistratura**.  

A inten√ß√£o √© compreender se existe **correla√ß√£o entre essas duas vari√°veis** ‚Äî o que pode ajudar a **validar os dados coletados** e oferecer um retrato mais preciso do **perfil dos julgadores** que atuam nas **C√¢maras Criminais**.  

---  

 **Selecione apenas uma linha por relator**, contendo suas informa√ß√µes de idade (`rel_idade`) e tempo de magistratura (`rel_tempo_magistratura`).  
 Crie um **gr√°fico de dispers√£o (`sns.scatterplot`)**, em que:  
   - o eixo **x** representa a idade (`rel_idade`);  
   - o eixo **y** representa o tempo de magistratura (`rel_tempo_magistratura`).  

O objetivo √© verificar visualmente se existe **correla√ß√£o positiva entre idade e tempo de magistratura** ‚Äî hip√≥tese que validaria a consist√™ncia dos dados.

```{pyodide}
#| exercise: ex_5


# CARREGA OS DADOS DENTRO DO BLOCO DO EXERC√çCIO (setup j√° carregou a base)
# --- Escreva sua solu√ß√£o aqui ---

```

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 1
Use `drop_duplicates('relator')` para garantir **apenas uma linha por relator** no DataFrame.
:::
:::

::: { .hint exercise="ex_5" }
::: { .callout-note collapse="false" }
## Dica 2 
Monte o gr√°fico com `sns.scatterplot()`, definindo `x='rel_idade'` e `y='rel_tempo_magistratura'`.  
Isso criar√° um **gr√°fico de dispers√£o** que permite observar a correla√ß√£o entre idade e tempo de carreira.
:::
:::

::: { .solution exercise="ex_5" }
::: { .callout-tip collapse="false" }

## Solu√ß√£o

```python
relatores = camaras.drop_duplicates('relator')[['relator', 'rel_idade', 'rel_tempo_magistratura']]

# Converte para num√©rico
relatores['rel_idade'] = pd.to_numeric(relatores['rel_idade'], errors='coerce')
relatores['rel_tempo_magistratura'] = pd.to_numeric(relatores['rel_tempo_magistratura'], errors='coerce')

sns.scatterplot(
    data=relatores,
    x='rel_idade',
    y='rel_tempo_magistratura'
)
plt.title("Correla√ß√£o entre Idade e Tempo de Magistratura (TJSP)", fontsize=12)
plt.xlabel("Idade do Relator")
plt.ylabel("Tempo de Magistratura (anos)")
plt.tight_layout()
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_5
#| check: true
import pandas as pd
feedback = None
try:
    result = globals().get("relatores", None)
    if result is None:
        for name, val in globals().items():
            if isinstance(val, pd.DataFrame):
                cols = {c.lower() for c in val.columns}
                if {"rel_idade","rel_tempo_magistratura"}.issubset(cols):
                    result = val
                    break
    if result is None:
        feedback = {"correct": False, "message": "N√£o encontrei o DataFrame de `relatores` (uma linha por relator)."}
    elif not isinstance(result, pd.DataFrame):
        feedback = {"correct": False, "message": "`relatores` existe mas n√£o √© DataFrame."}
    else:
        cols = {c.lower() for c in result.columns}
        if {"rel_idade","rel_tempo_magistratura"}.issubset(cols):
            feedback = {"correct": True, "message": "Excelente üéâ ‚Äî rela√ß√£o entre idade e tempo de magistratura identificada corretamente!"}
        else:
            feedback = {"correct": False, "message": "O DataFrame precisa conter 'rel_idade' e 'rel_tempo_magistratura'."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A **an√°lise da correla√ß√£o entre idade e tempo de magistratura** permite n√£o apenas **validar a qualidade dos dados**, mas tamb√©m compreender melhor o **perfil dos magistrados** que comp√µem as **C√¢maras Criminais**.  

Essa investiga√ß√£o pode revelar padr√µes de **progress√£o na carreira** e oferecer subs√≠dios para **pol√≠ticas de forma√ß√£o continuada** e **gest√£o de recursos humanos** no Poder Judici√°rio.
:::
## Exerc√≠cio 6 ‚Äî Prepara√ß√£o da Base Vivo

Imagine que voc√™ foi contratado para integrar o time jur√≠dico contencioso da Vivo, respons√°vel por analisar e acompanhar milhares de a√ß√µes judiciais movidas contra a empresa em todo o pa√≠s. Seu papel ser√° auxiliar na cria√ß√£o de indicadores e modelos preditivos capazes de antecipar os riscos e custos dessas demandas.

Antes de iniciar as an√°lises, a equipe de dados da Vivo notificou que foram encontradas algumas inconsist√™ncias na base de dados, que precisam ser corrigidas para garantir a confiabilidade dos resultados.

Para esta primeira etapa, seu objetivo √© preparar a base de dados de modo que ela contenha apenas as informa√ß√µes relevantes e completas para os casos em que j√° se conhece o desfecho da Vivo (isto √©, se a empresa ganhou ou perdeu a a√ß√£o).

---
 
Fa√ßa o filtro da base de dados para conter apenas as linhas correspondentes √† vit√≥ria ou derrota da Vivo e remova as linhas com valores ausentes nas vari√°veis `juiz_tempo_vara`, `pags_inicial` e `pags_contestacao`. Em seguida, informe quantas linhas restaram na base de dados ap√≥s esses filtros.

```{pyodide}
#| exercise: ex_6


import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

# --- Escreva sua solu√ß√£o aqui ---

```

::: { .hint exercise="ex_6" }
::: { .callout-note collapse="false" }
## Dica 1
Para filtrar a coluna desfecho_vivo, voc√™ pode criar uma lista com os dois valores desejados `(['Vit√≥ria', 'Derrota (Total ou Parcial)'])` e usar o m√©todo `.isin(lista)` para selecionar as linhas.
:::
:::

::: { .hint exercise="ex_6" }
::: { .callout-note collapse="false" }
## Dica 2 
Use `.dropna(subset=[...])` para remover linhas com valores nulos apenas nas colunas especificadas. Para obter a contagem final de linhas, use a fun√ß√£o `len(seu_dataframe)`
:::
:::

::: { .solution exercise="ex_6" }
::: { .callout-tip collapse="false" }

## Solu√ß√£o

```python
vivo_filtrado = vivo[vivo['desfecho_vivo'].isin(['Vit√≥ria', 'Derrota (Total ou Parcial)'])]
vivo_filtrado = vivo_filtrado.dropna(subset=['juiz_tempo_vara', 'pags_inicial', 'pags_contestacao'])
qtd_linhas = len(vivo_filtrado)
qtd_linhas
```
:::
:::

```{pyodide}
#| exercise: ex_6
#| check: true

import pandas as pd
feedback = None
result = None 
try:
    # Captura a vari√°vel de resposta do aluno
    result = qtd_linhas
    
    # --- ETAPA DE VALIDA√á√ÉO (RECRIA A SOLU√á√ÉO) ---
    # ATEN√á√ÉO: A URL abaixo √© uma suposi√ß√£o. 
    # Troque pelo caminho correto para o seu arquivo .csv
    url_check = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/vivo.csv"
    vivo_check = pd.read_csv(url_check, dtype=str)
    
    vivo_filtrado_check = vivo_check[vivo_check['desfecho_vivo'].isin(['Vit√≥ria', 'Derrota (Total ou Parcial)'])]
    vivo_filtrado_check = vivo_filtrado_check.dropna(subset=['juiz_tempo_vara', 'pags_inicial', 'pags_contestacao'])
    expected = len(vivo_filtrado_check)
    
    if result == expected:
        feedback = {"correct": True, "message": f"Perfeito! A base de dados filtrada e limpa resultou em {expected} linhas."}
    else:
        feedback = {"correct": False, "message": f"O n√∫mero de linhas n√£o est√° correto. Esperado: {expected}. Seu resultado: {result}."}

except NameError:
    feedback = {"correct": False, "message": "A vari√°vel `qtd_linhas` n√£o foi encontrada. Certifique-se de que ela √© a √∫ltima linha do seu c√≥digo."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}. (Verifique se a URL no bloco de check est√° correta)"}

feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A `qualidade dos dados (data quality)` √© a etapa mais cr√≠tica em qualquer projeto de Jurimetria. Modelos preditivos constru√≠dos sobre bases de dados "sujas" (com valores ausentes, duplicados ou inconsistentes) geram previs√µes n√£o confi√°veis.

No contexto corporativo, isso pode levar o escrit√≥rio a tomar decis√µes estrat√©gicas erradas, como provisionar valores incorretos para perdas, subestimar custos processuais ou perder oportunidades valiosas de acordo
:::

## Exerc√≠cio 7 ‚Äî Cria√ß√£o da Vari√°vel de Desfecho da Vivo

Ap√≥s a etapa inicial de limpeza dos dados, o time de dados da Vivo solicitou uma nova verifica√ß√£o.
Durante o desenvolvimento do painel de acompanhamento de resultados judiciais, a equipe percebeu que n√£o havia uma vari√°vel num√©rica que identificasse, de forma padronizada, se a decis√£o foi favor√°vel ou desfavor√°vel √† empresa.

Para possibilitar an√°lises estat√≠sticas e a futura constru√ß√£o de modelos preditivos, o jur√≠dico anal√≠tico pediu que voc√™ criasse uma nova coluna chamada `y`, que receba o valor **1** quando a decis√£o for favor√°vel √† Vivo e **0** caso contr√°rio.

Com base nessa nova vari√°vel, calcule tamb√©m a **propor√ß√£o** de decis√µes favor√°veis √† Vivo na base de dados. Essa m√©trica servir√° como indicador preliminar de desempenho da empresa no contencioso.

---

Crie a coluna `y` no DataFrame `vivo` (onde 1 = 'Vit√≥ria' e 0 para os demais casos). Em seguida, calcule a propor√ß√£o de vit√≥rias e armazene o resultado na vari√°vel `proporcao_vitorias`.

```{pyodide}
#| exercise: ex_7

# O DataFrame 'vivo' e as bibliotecas 'pd' e 'np' j√° foram carregados no setup global.

# --- Escreva sua solution aqui ---
```

::: { .hint exercise="ex_7" }
::: { .callout-note collapse="false" }
## Dica 1
Para criar a nova coluna `y` de forma condicional, a fun√ß√£o `np.where()` (do NumPy) √© ideal. A sintaxe √©: `np.where(condi√ß√£o, valor_se_verdadeiro, valor_se_falso)`
:::
:::

::: { .hint exercise="ex_7" }
::: { .callout-note collapse="false" }
## Dica 2 
Depois de criar a coluna `y` (que cont√©m apenas 1s e 0s), a propor√ß√£o de vit√≥rias √© simplesmente a m√©dia dessa coluna. Voc√™ pode calcular isso usando o m√©todo `.mean()`.
:::
:::

::: { .solution exercise="ex_7" }
::: { .callout-tip collapse="false" }

## Solu√ß√£o

```python
# 1. Criar a vari√°vel 'y'
vivo['y'] = np.where(vivo['desfecho_vivo'] == 'Vit√≥ria', 1, 0)

# 2. Calcular a propor√ß√£o de vit√≥rias
proporcao_vitorias = vivo['y'].mean()
proporcao_vitorias
```
:::
:::

```{pyodide}
#| exercise: ex_7
#| check: true

# Este bloco assume que 'vivo' e 'np' existem no escopo 'myenv'

feedback = None
result = None 
try:
    # Captura a vari√°vel de resposta do aluno
    result = proporcao_vitorias
    
    # --- ETAPA DE VALIDA√á√ÉO (RECRIA A SOLU√á√ÉO) ---
    # Usa o 'vivo' DataFrame e 'np' do setup global
    y_check = np.where(vivo['desfecho_vivo'] == 'Vit√≥ria', 1, 0)
    expected = y_check.mean()
    
    # Verifica se o 'y' foi criado no DataFrame original
    if 'y' not in vivo.columns:
        feedback = {"correct": False, "message": "A coluna 'y' n√£o foi criada no DataFrame `vivo`."}
    # Verifica se o valor da propor√ß√£o est√° correto
    elif (result is not None) and (abs(result - expected) < 0.0001):
        feedback = {"correct": True, "message": f"Correto! A propor√ß√£o de vit√≥rias √© de {expected*100:.2f}%."}
    else:
        feedback = {"correct": False, "message": f"O valor da propor√ß√£o n√£o est√° correto. Esperado: {expected:.4f}. Seu resultado: {result}."}

except NameError as e:
    if 'proporcao_vitorias' in str(e):
        feedback = {"correct": False, "message": "A vari√°vel `proporcao_vitorias` n√£o foi encontrada. Certifique-se de que ela √© a √∫ltima linha do seu c√≥digo."}
    elif 'vivo' in str(e) or 'np' in str(e):
        feedback = {"correct": False, "message": "Erro de Valida√ß√£o: O DataFrame `vivo` ou `np` n√£o foi encontrado. O setup global foi executado?"}
    else:
        feedback = {"correct": False, "message": f"Erro de Valida√ß√£o: {e}"}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}."}

feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

Transformar resultados categ√≥ricos (como "Vit√≥ria" ou "Derrota") em vari√°veis num√©ricas bin√°rias (1 ou 0) √© um passo fundamental em machine learning. Isso permite que algoritmos matem√°ticos, que n√£o entendem texto, possam processar e modelar desfechos.

A propor√ß√£o de vit√≥rias (a m√©dia da coluna `y`) √© uma m√©trica crucial. Ela √© conhecida como taxa de base (ou baseline). Qualquer modelo preditivo futuro que construir s√≥ ser√° √∫til se conseguir prever os resultados com uma acur√°cia maior do que essa taxa de base.
:::

## Exerc√≠cio 8 ‚Äî Cria√ß√£o de Vari√°veis Dummies para o Juiz

Ap√≥s as etapas iniciais de limpeza e estrutura√ß√£o dos dados, o time jur√≠dico-anal√≠tico da Vivo come√ßou a planejar a constru√ß√£o de modelos estat√≠sticos para prever o desfecho dos processos.

Durante as reuni√µes t√©cnicas, os analistas de dados destacaram que, para aplicar t√©cnicas de regress√£o log√≠stica e outros modelos de classifica√ß√£o, √© necess√°rio transformar vari√°veis categ√≥ricas em valores num√©ricos.

Uma das vari√°veis que precisam ser tratadas √© a que identifica o juiz respons√°vel pelo processo. Cada magistrado pode ter caracter√≠sticas e hist√≥ricos de decis√£o distintos, que podem influenciar o resultado das a√ß√µes.

Por isso, a equipe solicitou que voc√™ criasse uma base de vari√°veis dummies para a coluna `juiz`, utilizando a fun√ß√£o `pd.get_dummies()`.
Essas dummies representar√£o cada juiz da base de dados, com o valor 1 indicando a presen√ßa daquele juiz no processo, e 0 caso contr√°rio.

---

Crie a base de dummies a partir da coluna `juiz` do DataFrame `vivo_filtrado` (criado no Exerc√≠cio 6). Armazene o resultado em `dummies_juiz`.
N√£o remova a primeira categoria (isto √©, n√£o utilize o par√¢metro `drop_first=True`).
Por fim, armazene o n√∫mero de colunas da base resultante na vari√°vel `n_col_dummies` e imprima esse valor.

```{pyodide}
#| exercise: ex_8

# O DataFrame 'vivo_filtrado' (do Ex 1) e 'pd' j√° foram carregados no setup global.

# --- Escreva sua solu√ß√£o aqui ---
```

::: { .hint exercise="ex_8" }
::: { .callout-note collapse="false" }
## Dica 1
A fun√ß√£o para criar vari√°veis `dummies` (One-Hot Encoding) no pandas √© `pd.get_dummies()`. Basta passar a coluna do DataFrame como argumento (ex: `pd.get_dummies(seu_dataframe['sua_coluna'])`).
:::
:::

::: { .hint exercise="ex_8" }
::: { .callout-note collapse="false" }
## Dica 2 
Todo DataFrame do pandas possui o atributo .shape, que retorna uma tupla (linhas, colunas). Para pegar apenas o n√∫mero de colunas, voc√™ pode usar `seu_dataframe.shape[1]`.
:::
:::

::: { .solution exercise="ex_8" }
::: { .callout-tip collapse="false" }

## Solu√ß√£o

```python
dummies_juiz = pd.get_dummies(vivo_filtrado['juiz'])

n_col_dummies = dummies_juiz.shape[1]

print(n_col_dummies)
```
:::
:::

```{pyodide}
#| exercise: ex_8
#| check: true

# Este bloco assume que 'vivo' (o original) e 'pd' existem no escopo global

feedback = None
result_df = None
result_cols = None

try:
    # Captura as vari√°veis de resposta do aluno
    result_df = dummies_juiz
    result_cols = n_col_dummies
    
    # --- ETAPA DE VALIDA√á√ÉO (RECRIA A SOLU√á√ÉO) ---
    # Recria o vivo_filtrado do Exerc√≠cio 1 para um check robusto
    vivo_filtrado_check = vivo[vivo['desfecho_vivo'].isin(['Vit√≥ria', 'Derrota (Total ou Parcial)'])]
    vivo_filtrado_check = vivo_filtrado_check.dropna(subset=['juiz_tempo_vara', 'pags_inicial', 'pags_contestacao'])
    
    # Recria a solu√ß√£o esperada
    expected_dummies = pd.get_dummies(vivo_filtrado_check['juiz'])
    expected_n_cols = expected_dummies.shape[1]
    
    # Valida√ß√£o
    if not isinstance(result_df, pd.DataFrame):
        feedback = {"correct": False, "message": "A vari√°vel `dummies_juiz` n√£o foi criada corretamente como um DataFrame."}
    elif result_df.shape[1] != expected_n_cols:
        feedback = {"correct": False, "message": f"O DataFrame `dummies_juiz` n√£o tem o n√∫mero correto de colunas. Esperado: {expected_n_cols}. Seu resultado: {result_df.shape[1]}."}
    elif result_cols != expected_n_cols:
        feedback = {"correct": False, "message": f"A vari√°vel `n_col_dummies` n√£o tem o valor correto. Esperado: {expected_n_cols}. Seu resultado: {result_cols}."}
    else:
        feedback = {"correct": True, "message": f"Correto! A transforma√ß√£o resultou em {expected_n_cols} colunas (uma para cada juiz)."}

except NameError as e:
    if 'dummies_juiz' in str(e):
        feedback = {"correct": False, "message": "A vari√°vel `dummies_juiz` n√£o foi encontrada."}
    elif 'n_col_dummies' in str(e):
        feedback = {"correct": False, "message": "A vari√°vel `n_col_dummies` n√£o foi encontrada."}
    elif 'vivo_filtrado' in str(e):
        feedback = {"correct": False, "message": "O DataFrame `vivo_filtrado` (do Exerc√≠cio 1) n√£o foi encontrado. Voc√™ executou o Exerc√≠cio 1?"}
    else:
        feedback = {"correct": False, "message": f"Erro de Valida√ß√£o: {e}"}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}."}

feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

Transformar vari√°veis categ√≥ricas como "juiz" em `dummies` (tamb√©m chamado de One-Hot Encoding) √© essencial. Modelos matem√°ticos, como a regress√£o log√≠stica, n√£o entendem categorias de texto ("Juiz A", "Juiz B").

Ao criar uma coluna para cada juiz (ex: `juiz_A`, `juiz_B`), o modelo pode atribuir um peso (coeficiente) individual a cada magistrado, aprendendo se a presen√ßa de um juiz espec√≠fico aumenta ou diminui estatisticamente a chance de "Vit√≥ria" da empresa.
:::

## Exerc√≠cio 9 ‚Äî Sele√ß√£o de Dummies Relevantes

Com a base de vari√°veis dummies criada, o time jur√≠dico-anal√≠tico da Vivo identificou um novo desafio.
Alguns ju√≠zes possuem apenas poucos processos na amostra, o que pode introduzir ru√≠do estat√≠stico nos modelos preditivos e dificultar a interpreta√ß√£o dos resultados.

Para garantir an√°lises mais robustas, a equipe solicitou que fossem mantidos apenas os ju√≠zes com quantidade relevante de observa√ß√µes na base de dados.

---

Com base na estrutura criada em `dummies_juiz` (do Exerc√≠cio 8), gere uma nova base contendo apenas as colunas correspondentes aos ju√≠zes que possuem **mais de 50 processos** registrados.

Armazene o resultado na vari√°vel `dummies_juiz_select` e informe quantas colunas a base resultante possui, armazenando este n√∫mero na vari√°vel `n_col_dummies_select` e imprimindo o valor.

```{pyodide}
#| exercise: ex_9

# O DataFrame 'dummies_juiz' (do Ex 8) e 'pd' j√° foram carregados.

# --- Escreva sua solu√ß√£o aqui ---
```

::: { .hint exercise="ex_9" }
::: { .callout-note collapse="false" }
## Dica 1
Como o DataFrame `dummies_juiz` cont√©m 1s e 0s, voc√™ pode obter a contagem de processos por juiz simplesmente somando as colunas. Use o m√©todo `.sum()` no DataFrame. O resultado ser√° uma Series onde o √≠ndice √© o nome do juiz e o valor √© a contagem.
:::
:::

::: { .hint exercise="ex_9" }
::: { .callout-note collapse="false" }
## Dica 2 
Filtre a Series da Dica 1 para manter apenas os valores `> 50`. Em seguida, extraia o `.index` (que s√£o os nomes dos ju√≠zes selecionados) e use essa lista para filtrar as colunas do DataFrame `dummies_juiz` original.
:::
:::

::: { .solution exercise="ex_9" }
::: { .callout-tip collapse="false" }

## Solu√ß√£o

```python
frequencias = dummies_juiz.sum()
juizes_selecionados = frequencias[frequencias > 50].index
dummies_juiz_select = dummies_juiz[juizes_selecionados]
n_col_dummies_select = dummies_juiz_select.shape[1]

print(n_col_dummies_select)
```
:::
:::

```{pyodide}
#| exercise: ex_9
#| check: true

# Este bloco assume que 'vivo' (o original) e 'pd' existem no escopo global

feedback = None
result_df = None
result_cols = None

try:
    # Captura as vari√°veis de resposta do aluno
    result_df = dummies_juiz_select
    result_cols = n_col_dummies_select
    
    # --- ETAPA DE VALIDA√á√ÉO (RECRIA A SOLU√á√ÉO) ---
    # Recria o vivo_filtrado (do Ex 1)
    vivo_filtrado_check = vivo[vivo['desfecho_vivo'].isin(['Vit√≥ria', 'Derrota (Total ou Parcial)'])]
    vivo_filtrado_check = vivo_filtrado_check.dropna(subset=['juiz_tempo_vara', 'pags_inicial', 'pags_contestacao'])
    
    # Recria o dummies_juiz (do Ex 8)
    dummies_juiz_check = pd.get_dummies(vivo_filtrado_check['juiz'])
    
    # Recria a solu√ß√£o esperada
    frequencias = dummies_juiz_check.sum()
    juizes_selecionados = frequencias[frequencias > 50].index
    expected_dummies = dummies_juiz_check[juizes_selecionados]
    expected_n_cols = expected_dummies.shape[1]
    
    # Valida√ß√£o
    if not isinstance(result_df, pd.DataFrame):
        feedback = {"correct": False, "message": "A vari√°vel `dummies_juiz_select` n√£o foi criada corretamente como um DataFrame."}
    elif result_df.shape[1] != expected_n_cols:
        feedback = {"correct": False, "message": f"O DataFrame `dummies_juiz_select` n√£o tem o n√∫mero correto de colunas. Esperado: {expected_n_cols}. Seu resultado: {result_df.shape[1]}."}
    elif result_cols != expected_n_cols:
        feedback = {"correct": False, "message": f"A vari√°vel `n_col_dummies_select` n√£o tem o valor correto. Esperado: {expected_n_cols}. Seu resultado: {result_cols}."}
    else:
        feedback = {"correct": True, "message": f"Correto! Apenas {expected_n_cols} ju√≠zes possuem mais de 50 processos na base."}

except NameError as e:
    if 'dummies_juiz_select' in str(e):
        feedback = {"correct": False, "message": "A vari√°vel `dummies_juiz_select` n√£o foi encontrada."}
    elif 'n_col_dummies_select' in str(e):
        feedback = {"correct": False, "message": "A vari√°vel `n_col_dummies_select` n√£o foi encontrada."}
    elif 'dummies_juiz' in str(e):
        feedback = {"correct": False, "message": "O DataFrame `dummies_juiz` (do Exerc√≠cio 8) n√£o foi encontrado. Voc√™ executou o Exerc√≠cio 8?"}
    else:
        feedback = {"correct": False, "message": f"Erro de Valida√ß√£o: {e}"}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}."}

feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

Esta etapa √© um exemplo cl√°ssico de sele√ß√£o de features (feature selection). No contexto jur√≠dico, um juiz com pouqu√≠ssimos casos (ex: 2 ou 3 processos) n√£o oferece informa√ß√£o estat√≠stica suficiente para o modelo aprender um padr√£o.

Manter essas dummies "raras" pode ser prejudicial, fazendo o modelo dar um peso indevido a uma coincid√™ncia (ex: se um juiz julgou 2 casos e a Vivo perdeu ambos). Ao filtrar e manter apenas ju√≠zes com um volume relevante (ex: > 50 casos), garantimos que o modelo aprenda padr√µes mais robustos e estatisticamente est√°veis.

:::

## Exerc√≠cio 10 ‚Äî Consolida√ß√£o da Base de Modelagem

Com as etapas anteriores conclu√≠das, o time jur√≠dico-anal√≠tico da Vivo est√° pronto para iniciar a fase de modelagem preditiva.
O objetivo agora √© criar uma base consolidada que contenha apenas as vari√°veis consideradas mais relevantes para prever o desfecho dos processos.

Ap√≥s reuni√µes com os advogados internos e especialistas em dados, foi definido que a base final deve incluir:

* as vari√°veis num√©ricas principais: `valor`, `pags_inicial`, `pags_contestacao` e `juiz_tempo_vara`, que representam aspectos financeiros e processuais relevantes;
* e as vari√°veis dummies correspondentes aos ju√≠zes com mais de 50 processos, previamente armazenadas na base `dummies_juiz_select`.

---

Com base nisso, crie uma nova base chamada `vivo_f`, contendo as vari√°veis listadas acima.
Em seguida, armazene o n√∫mero de linhas e colunas da base resultante nas vari√°veis `n_linhas` e `n_colunas`, e imprima o resultado.

```{pyodide}
#| exercise: ex_10

# Os DataFrames 'vivo_filtrado' (Ex 1), 'dummies_juiz_select' (Ex 9) 
# e 'pd' j√° existem no escopo.

# --- Escreva sua solu√ß√£o aqui ---
```

::: { .hint exercise="ex_10" }
::: { .callout-note collapse="false" }
## Dica 1
Primeiro, crie uma lista com os nomes das colunas num√©ricas (ex: `cols = ['valor', 'pags_inicial', ...]`). Use essa lista para selecionar apenas essas colunas do DataFrame `vivo_filtrado`.
:::
:::

::: { .hint exercise="ex_10" }
::: { .callout-note collapse="false" }
## Dica 2 
Para juntar o DataFrame num√©rico (da Dica 1) com o `dummies_juiz_select`, use a fun√ß√£o `pd.concat()`. Lembre-se de especificar `axis=1` para juntar as colunas lado a lado.
:::
:::

::: { .solution exercise="ex_10" }
::: { .callout-tip collapse="false" }

## Solu√ß√£o

```python
# Define as colunas num√©ricas
numeric_cols = ['valor', 'pags_inicial', 'pags_contestacao', 'juiz_tempo_vara']
vivo_numeric = vivo_filtrado[numeric_cols]

# Concatena com as dummies (do exerc√≠cio anterior)
vivo_f = pd.concat([vivo_numeric, dummies_juiz_select], axis=1)

# Informa as dimens√µes
n_linhas = vivo_f.shape[0]
n_colunas = vivo_f.shape[1]

print(f"Base final criada com {n_linhas} linhas e {n_colunas} colunas.")
```
:::
:::

```{pyodide}
#| exercise: ex_10
#| check: true

# Este bloco assume que 'vivo' (o original) e 'pd' existem no escopo global

feedback = None
result_df = None
result_rows = None
result_cols = None

try:
    # Captura as vari√°veis do aluno
    result_df = vivo_f
    result_rows = n_linhas
    result_cols = n_colunas
    
    # --- ETAPA DE VALIDA√á√ÉO (RECRIA TUDO) ---
    # 1. Recria vivo_filtrado (de Ex 1)
    vivo_filtrado_check = vivo[vivo['desfecho_vivo'].isin(['Vit√≥ria', 'Derrota (Total ou Parcial)'])]
    vivo_filtrado_check = vivo_filtrado_check.dropna(subset=['juiz_tempo_vara', 'pags_inicial', 'pags_contestacao'])
    
    # 2. Recria dummies_juiz (de Ex 8)
    dummies_juiz_check = pd.get_dummies(vivo_filtrado_check['juiz'])
    
    # 3. Recria dummies_juiz_select (de Ex 9)
    frequencias = dummies_juiz_check.sum()
    juizes_selecionados = frequencias[frequencias > 50].index
    dummies_juiz_select_check = dummies_juiz_check[juizes_selecionados]
    
    # 4. Recria a solu√ß√£o (Ex 10)
    numeric_cols = ['valor', 'pags_inicial', 'pags_contestacao', 'juiz_tempo_vara']
    vivo_numeric_check = vivo_filtrado_check[numeric_cols]
    expected_df = pd.concat([vivo_numeric_check, dummies_juiz_select_check], axis=1)
    expected_rows = expected_df.shape[0]
    expected_cols = expected_df.shape[1]
    
    # Valida√ß√£o
    if not isinstance(result_df, pd.DataFrame):
        feedback = {"correct": False, "message": "A vari√°vel `vivo_f` n√£o foi criada como um DataFrame."}
    elif result_rows != expected_rows:
        feedback = {"correct": False, "message": f"O n√∫mero de linhas em `n_linhas` est√° incorreto. Esperado: {expected_rows}. Seu resultado: {result_rows}."}
    elif result_cols != expected_cols:
        feedback = {"correct": False, "message": f"O n√∫mero de colunas em `n_colunas` est√° incorreto. Esperado: {expected_cols}. Seu resultado: {result_cols}."}
    else:
        feedback = {"correct": True, "message": f"Excelente! A base final `vivo_f` foi consolidada com {expected_rows} linhas e {expected_cols} colunas."}

except NameError as e:
    if 'vivo_f' in str(e):
        feedback = {"correct": False, "message": "A vari√°vel `vivo_f` n√£o foi encontrada."}
    elif 'n_linhas' in str(e) or 'n_colunas' in str(e):
        feedback = {"correct": False, "message": "As vari√°veis `n_linhas` ou `n_colunas` n√£o foram encontradas."}
    elif 'dummies_juiz_select' in str(e):
        feedback = {"correct": False, "message": "O DataFrame `dummies_juiz_select` (do Exerc√≠cio 9) n√£o foi encontrado. Voc√™ executou o Exerc√≠cio 9?"}
    else:
        feedback = {"correct": False, "message": f"Erro de Valida√ß√£o: {e}"}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}."}

feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

Esta √© a etapa final de prepara√ß√£o de dados, onde criamos a matriz de features (ou `X`). Esta base `vivo_f` cont√©m todas as informa√ß√µes que o modelo preditivo usar√° para "aprender" os padr√µes que levam a uma vit√≥ria ou derrota (que est√° na vari√°vel `y`, criada no Exerc√≠cio 7).

A escolha de quais colunas incluir (num√©ricas, dummies) √© um passo crucial que combina conhecimento jur√≠dico (o que realmente importa para o caso?) e estat√≠stico (o que o modelo consegue usar para prever?).

:::

## Exerc√≠cio 11 ‚Äî Ajuste de um Modelo Log√≠stico Simplificado

Ap√≥s a cria√ß√£o da base de dados completa, a equipe de dados da Vivo solicitou um primeiro teste de modelagem.

Antes de usar o modelo completo (com todas as *dummies* de ju√≠zes), a equipe quer avaliar o poder preditivo de um modelo mais simples, usando apenas as vari√°veis `valor` e `juiz_tempo_vara`.

O objetivo √© criar um "modelo de base" simplificado para comparar com as vers√µes mais complexas no futuro.

---

Crie um modelo de regress√£o log√≠stica usando **apenas** `valor` e `juiz_tempo_vara` do `vivo_f` como `X`, e a coluna `y` do `vivo_filtrado` como `y`.

Divida os dados em treino e teste (30% para teste, `random_state=1`, estratificado por `y`).

Ajuste o modelo (`LogisticRegression(max_iter=10000)`) e, por fim, imprima na mesma linha:
1.  A propor√ß√£o de vit√≥rias na base de **treino** (`prop_y_train`).
2.  A propor√ß√£o de vit√≥rias na base de **teste** (`prop_y_test`).
3.  A acur√°cia final do modelo (`acc`).

```{pyodide}
#| exercise: ex_11

# As bibliotecas (incluindo sklearn) e os DataFrames 
# 'vivo_f' (X) e 'vivo_filtrado' (de onde tiramos y) j√° est√£o no escopo.

# --- Escreva sua solu√ß√£o aqui ---
```

::: { .hint exercise="ex_11" }
::: { .callout-note collapse="false" }
## Dica 1
Desta vez, seu `X` n√£o ser√° o `vivo_f` inteiro. Crie o `X` selecionando apenas as duas colunas pedidas: `X = vivo_f[['valor', 'juiz_tempo_vara']]`. O `y` continua vindo do `vivo_filtrado['y']`.
:::
:::

::: { .hint exercise="ex_11" }
::: { .callout-note collapse="false" }
## Dica 2 
Lembre-se de usar `random_state=1` no `train_test_split` para este exerc√≠cio. Para calcular as propor√ß√µes, use `.mean()` nas vari√°veis `y_train` e `y_test`.
:::
:::

::: { .solution exercise="ex_11" }
::: { .callout-tip collapse="false" }

## Solu√ß√£o

```python
# 1. Definir X (simplificado) e y
X = vivo_f[['valor', 'juiz_tempo_vara']]
y = vivo_filtrado['y'] # Corrigido (n√£o est√° em vivo_f)

# 2. Dividir os dados com random_state=1
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=1, stratify=y
)

# 3. Calcular propor√ß√µes
prop_y_train = y_train.mean()
prop_y_test = y_test.mean()

# 4. Criar e treinar o modelo
model = LogisticRegression(max_iter=10000)
model.fit(X_train, y_train)

# 5. Fazer previs√µes e calcular acur√°cia
y_pred = model.predict(X_test)
acc = accuracy_score(y_test, y_pred)

print(prop_y_train, prop_y_test, acc)
```
:::
:::

```{pyodide}
#| exercise: ex_11
#| check: true

# Este bloco assume que as vari√°veis do setup ('vivo_f', 'vivo_filtrado')
# e as bibliotecas ('pd', 'np', 'sklearn.*') est√£o no escopo global.

feedback = None
result_acc = None 
result_prop_train = None
result_prop_test = None

try:
    # Captura as vari√°veis de resposta do aluno
    result_acc = acc
    result_prop_train = prop_y_train
    result_prop_test = prop_y_test
    
    # --- ETAPA DE VALIDA√á√ÉO (RECRIA A SOLU√á√ÉO) ---
    X_check = vivo_f[['valor', 'juiz_tempo_vara']]
    y_check = vivo_filtrado['y'] 

    X_train_check, X_test_check, y_train_check, y_test_check = train_test_split(
        X_check, y_check, test_size=0.3, random_state=1, stratify=y_check
    )
    
    expected_prop_train = y_train_check.mean()
    expected_prop_test = y_test_check.mean()
    
    model_check = LogisticRegression(max_iter=10000)
    model_check.fit(X_train_check, y_train_check)
    y_pred_check = model_check.predict(X_test_check)
    expected_acc = accuracy_score(y_test_check, y_pred_check)
    
    # Valida√ß√£o
    if result_acc is None:
        feedback = {"correct": False, "message": "A vari√°vel `acc` n√£o foi encontrada."}
    elif abs(result_acc - expected_acc) > 0.0001:
        feedback = {"correct": False, "message": f"O valor da acur√°cia `acc` n√£o est√° correto. Esperado: {expected_acc:.4f}. Seu resultado: {result_acc:.4f}."}
    elif abs(result_prop_train - expected_prop_train) > 0.0001:
        feedback = {"correct": False, "message": f"O valor de `prop_y_train` n√£o est√° correto. Esperado: {expected_prop_train:.4f}."}
    elif abs(result_prop_test - expected_prop_test) > 0.0001:
        feedback = {"correct": False, "message": f"O valor de `prop_y_test` n√£o est√° correto. Esperado: {expected_prop_test:.4f}."}
    else:
        feedback = {"correct": True, "message": f"Correto! Acur√°cia: {expected_acc*100:.2f}%. Propor√ß√µes (T/T): {expected_prop_train:.3f} / {expected_prop_test:.3f}."}

except NameError as e:
    if 'acc' in str(e) or 'prop_y_train' in str(e) or 'prop_y_test' in str(e):
        feedback = {"correct": False, "message": "Uma das vari√°veis (`acc`, `prop_y_train` ou `prop_y_test`) n√£o foi encontrada."}
    elif 'vivo_f' in str(e) or 'vivo_filtrado' in str(e):
        feedback = {"correct": False, "message": "Os DataFrames `vivo_f` ou `vivo_filtrado` n√£o foram encontrados. O setup global foi executado?"}
    elif 'LogisticRegression' in str(e):
         feedback = {"correct": False, "message": "Fun√ß√µes do 'sklearn' n√£o foram encontradas. Verifique se elas est√£o no seu bloco de setup."}
    else:
        feedback = {"correct": False, "message": f"Erro de Valida√ß√£o: {e}"}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}."}

feedback
```

::: {.callout-tip icon="‚öñÔ∏è"}
### Relev√¢ncia jur√≠dica  

A acur√°cia √© a m√©trica mais fundamental para um modelo de classifica√ß√£o. Ela responde √† pergunta: "De 100 processos que o modelo analisou, quantos ele acertou (Vit√≥ria/Derrota)?"

Neste exerc√≠cio, usamos um modelo "simples" (com apenas 2 vari√°veis). Ele serve como um baseline de performance. Qualquer modelo futuro, mais complexo (como o que usa todas as dummies de ju√≠zes), s√≥ ser√° considerado "melhor" se apresentar uma acur√°cia significativamente maior do que esta.

:::




