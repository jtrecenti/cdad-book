---
title: Exerc√≠cios
format: live-html
---

## Exerc√≠cio 1 ‚Äî **Panorama de Decis√µes**

## Contexto jur√≠dico  
Uma autoridade do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)** solicitou um relat√≥rio preliminar que apresente um panorama geral das decis√µes proferidas nas **C√¢maras Criminais**.  

O objetivo √© compreender a **distribui√ß√£o das decis√µes** conforme o tipo de provimento concedido ‚Äî se os recursos foram **negados**, **providos**, **parcialmente providos** ou se houve **extin√ß√£o da punibilidade**.  

Esse levantamento servir√° como base para um **estudo comparativo futuro** entre o TJSP e outros tribunais estaduais, buscando identificar poss√≠veis **padr√µes de julgamento** e **varia√ß√µes na aplica√ß√£o de precedentes**.  

***

Utilizando a base de dados `camaras`, elabore um **resumo quantitativo das decis√µes**, agrupando-as por **tipo de decis√£o**.  
Apresente o resultado em formato de tabela e, se desejar, complemente com um gr√°fico simples (ex.: `barplot` ou `value_counts().plot.bar()`).

```{pyodide}
#| setup: true
#| exercise: ex_1
import pandas as pd
url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
print("SETUP ok ‚Äî colunas:", list(camaras.columns)[:10])
```

```{pyodide}
#| exercise: ex_1
# Escreva sua solu√ß√£o aqui:
# Agrupe as decis√µes usando value_counts() e renomeie a coluna de contagem.
```

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 1
Use `camaras["decisao"].value_counts()` para contar quantas vezes cada tipo de decis√£o aparece.
:::
:::

::: { .hint exercise="ex_1" }
::: { .callout-note collapse="false" }
## Dica 2
 Depois, transforme o resultado em DataFrame com `.reset_index(name="qtd_decisoes")`.
:::
:::

::: { .solution exercise="ex_1" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o
```python
total_decisoes = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes")
total_decisoes.head()
```
:::
:::

```{pyodide}
#| exercise: ex_1
#| check: true
# Checador autom√°tico ‚Äî compara o resultado do aluno com o DataFrame esperado.

import pandas as pd
feedback = None
try:
    expected = camaras["decisao"].value_counts().reset_index(name="qtd_decisoes").reset_index(drop=True)
    if isinstance(result, pd.DataFrame):
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        # tenta identificar colunas
        if "decisao" in res.columns or "index" in res.columns:
            ok_cols = any("qtd" in c for c in res.columns)
            if ok_cols and len(res) == len(expected):
                feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî seu resumo de decis√µes est√° correto!"}
            else:
                feedback = {"correct": False, "message": "As colunas ou contagens n√£o correspondem. Verifique o uso de value_counts() e reset_index()."}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter a coluna 'decisao' e a contagem ('qtd_decisoes')."}
    else:
        feedback = {"correct": False, "message": "Retorne um DataFrame (total_decisoes) para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}

feedback
```
## Exerc√≠cio 2 ‚Äî **Distribui√ß√£o de Decis√µes por C√¢mara**

### ‚öñÔ∏è Enunciado  

Em seguida, vamos supor que a mesma autoridade tenha solicitado uma **an√°lise complementar** com o objetivo de verificar a **quantidade de decis√µes proferidas por cada C√¢mara** do **Tribunal de Justi√ßa de S√£o Paulo (TJSP)**.  

Como essa apresenta√ß√£o ser√° encaminhada para um **congresso dedicado ao estudo da distribui√ß√£o de decis√µes entre as C√¢maras**, optou-se por representar os resultados em **formato gr√°fico**, de modo a proporcionar uma visualiza√ß√£o mais clara, comparativa e intuitiva do volume de decis√µes analisadas.  

---

### üß† Tarefa  
Utilizando a base `camaras`, elabore um **gr√°fico de barras** que mostre a quantidade total de decis√µes por **C√¢mara** (`camara`).  
Use o `value_counts()` para obter os totais e o `seaborn.barplot()` para montar o gr√°fico.

---

```{pyodide}
#| setup: true
#| exercise: ex_2
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"
camaras = pd.read_csv(url, dtype=str)
camaras.columns = [c.strip().lower().replace(" ", "_") for c in camaras.columns]
```

```{pyodide}
#| exercise: ex_2
# Escreva sua solu√ß√£o aqui:
# 1Ô∏è‚É£ Agrupe por 'camara' e conte as decis√µes.
# 2Ô∏è‚É£ Gere um gr√°fico de barras (horizontal) com seaborn.

# Exemplo de passos (comente ou apague antes de submeter):
# total_decisoes_por_camara = camaras['camara'].value_counts().reset_index(name='qtd_decisoes')
# sns.barplot(data=total_decisoes_por_camara, y='camara', x='qtd_decisoes', color='royalblue')
# plt.show()
```

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
**Dica 1:**  
Use `value_counts()` para contar quantas decis√µes h√° em cada C√¢mara.
:::
:::

::: { .hint exercise="ex_2" }
::: { .callout-note collapse="false" }
**Dica 2:**  
Para visualizar, use `sns.barplot()` com `x='qtd_decisoes'`, `y='camara'` e uma cor (`color='royalblue'`).
:::
:::

::: { .solution exercise="ex_2" }
::: { .callout-tip collapse="false" }
**Solu√ß√£o**
```python
total_decisoes_por_camara = camaras["camara"].value_counts().reset_index(name="qtd_decisoes")

sns.barplot(
    data=total_decisoes_por_camara,
    y="camara",
    x="qtd_decisoes",
    color="royalblue"
)
plt.show()
```
:::
:::

```{pyodide}
#| exercise: ex_2
#| check: true
import pandas as pd
feedback = None
try:
    expected = camaras["camara"].value_counts().reset_index(name="qtd_decisoes").reset_index(drop=True)
    if isinstance(result, pd.DataFrame):
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        if "camara" in res.columns and any("qtd" in c for c in res.columns):
            if len(res) == len(expected):
                feedback = {"correct": True, "message": "Perfeito üéâ ‚Äî gr√°fico e tabela de decis√µes por C√¢mara est√£o corretos!"}
            else:
                feedback = {"correct": False, "message": "A contagem n√£o bate com o esperado. Verifique se usou value_counts()."}
        else:
            feedback = {"correct": False, "message": "O DataFrame deve conter colunas 'camara' e 'qtd_decisoes'."}
    else:
        feedback = {"correct": False, "message": "Retorne o DataFrame total_decisoes_por_camara antes do gr√°fico para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}
feedback
```


## Exerc√≠cio 3 ‚Äî Filtrar por anos e contagem por ano (2020 & 2021)

Usando o DataFrame `camaras`, filtre apenas os registros dos anos **2020** e **2021** e:
1. Calcule o total de registros por `ano`.
2. Mostre os 3 relatores (`relator`) com mais registros nesse per√≠odo.

```{pyodide}
#| setup: true
#| exercise: ex_3
# Setup robusto para pyodide ‚Äî garante que 'camaras' e 'ano' existam no runtime do navegador.
import pandas as pd
import io, sys

url = "https://raw.githubusercontent.com/jtrecenti/camaras-test/refs/heads/main/camaras.csv"

camaras = pd.DataFrame()
# tenta carregar do raw github, sen√£o tenta arquivo local
for src in (url, "data/camaras.csv", "camaras.csv"):
    try:
        camaras = pd.read_csv(src, dtype=str)
        break
    except Exception:
        continue

# normalizar nomes de colunas
camaras.columns = [str(c).strip() for c in camaras.columns]
camaras.rename(columns={c: c.lower().replace(" ", "_") for c in camaras.columns}, inplace=True)

# garantir coluna 'ano': tentar dt_publicacao -> ano; sen√£o extrair 4 d√≠gitos
if "ano" not in camaras.columns:
    if "dt_publicacao" in camaras.columns:
        try:
            camaras["ano"] = pd.to_datetime(camaras["dt_publicacao"], errors="coerce").dt.year
        except Exception:
            camaras["ano"] = pd.NA
    else:
        # tentar extrair ano de colunas prov√°veis
        found = False
        for col in ["processo", "ementa", "assunto"]:
            if col in camaras.columns:
                yrs = camaras[col].astype(str).str.extract(r"([12][0-9]{3})")
                if yrs.notna().any().any():
                    camaras["ano"] = pd.to_numeric(yrs[0], errors="coerce")
                    found = True
                    break
        if not found:
            camaras["ano"] = pd.NA

# for√ßar tipo int onde poss√≠vel (usar Int64 para permitir NA)
if "ano" in camaras.columns:
    try:
        camaras["ano"] = pd.to_numeric(camaras["ano"], errors="coerce").astype("Int64")
    except Exception:
        pass

# garantir colunas textuais usadas nos exerc√≠cios
for col in ("relator", "camara", "assunto"):
    if col not in camaras.columns:
        camaras[col] = ""

# debug minimal (aparece no preview para confirmar)
print("SETUP: colunas =", list(camaras.columns))
print("SETUP: n rows =", len(camaras))
```

```{pyodide}
#| exercise: ex_3

# A √∫ltima express√£o deve retornar `total_por_ano` para que o checador valide corretamente.

# --- escreva sua solu√ß√£o aqui (aluno) ---
```

::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 1
 Use `df_20_21 = camaras[camaras["ano"].isin([2020, 2021])]`.  
:::
:::
::: { .hint exercise="ex_3" }
::: { .callout-note collapse="false" }
## Dica 2
 Use `groupby(...).size()` e renomeie a coluna de contagem com `.rename(columns={"size":"n_registros"})`.
:::
:::

::: { .solution exercise="ex_3" }
::: { .callout-tip collapse="false" }
## Solu√ß√£o

```python
df_20_21 = camaras[camaras["ano"].isin([2020, 2021])]
total_por_ano = df_20_21.groupby("ano", as_index=False).size().rename(columns={"size":"n_registros"}).sort_values("ano")
top_relatores = df_20_21.groupby("relator", as_index=False).size().rename(columns={"size":"n_registros"}).sort_values("n_registros", ascending=False).head(3)
total_por_ano
```
:::
:::

```{pyodide}
#| exercise: ex_3
#| check: true
# Checador autom√°tico: compara o DataFrame retornado pelo aluno (result) com o esperado.
import pandas as pd

feedback = None
try:
    # construir esperado a partir da base carregada no setup
    expected = camaras[camaras["ano"].isin([2020, 2021])].groupby("ano", as_index=False).size().rename(columns={"size":"n_registros"}).sort_values("ano").reset_index(drop=True)

    if isinstance(result, pd.DataFrame):
        # normaliza colunas do resultado do aluno
        res = result.rename(columns={c: c.lower().replace(" ", "_") for c in result.columns})
        if "ano" not in res.columns:
            feedback = {"correct": False, "message": "Retorne um DataFrame com a coluna 'ano' e a contagem (ex.: 'n_registros')."}
        else:
            # identificar coluna de contagem (primeira que n√£o seja 'ano')
            count_cols = [c for c in res.columns if c != "ano"]
            if len(count_cols) == 0:
                feedback = {"correct": False, "message": "Seu DataFrame precisa ter 'ano' e uma coluna de contagem (ex.: 'n_registros')."}
            else:
                cnt = count_cols[0]
                res2 = res[["ano", cnt]].rename(columns={cnt: "n_registros"})
                # garantir tipos compat√≠veis
                res2["ano"] = pd.to_numeric(res2["ano"], errors="coerce").astype("Int64")
                expected["ano"] = pd.to_numeric(expected["ano"], errors="coerce").astype("Int64")
                res2 = res2.sort_values("ano").reset_index(drop=True)
                expected2 = expected.sort_values("ano").reset_index(drop=True)
                # comparar
                equal = res2.equals(expected2)
                if equal:
                    feedback = {"correct": True, "message": "Perfeito ‚Äî total_por_ano est√° correto üéâ"}
                else:
                    feedback = {"correct": False, "message": "Valores n√£o conferem com o esperado. Verifique o filtro por ano e a agrega√ß√£o (groupby/count)."}
    else:
        feedback = {"correct": False, "message": "Retorne um DataFrame (total_por_ano) para valida√ß√£o."}
except Exception as e:
    feedback = {"correct": False, "message": f"Erro ao validar: {e}"}

feedback
```

### Exerc√≠cio 4
